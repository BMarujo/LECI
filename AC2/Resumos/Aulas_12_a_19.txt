Barramentos paralelo vs série

• Barramentos: interligação dos blocos de um sistema de computação
• CPU, memória, unidades de I/O
• Tipos de dispositivos ligados a um barramento:
• Bus Master – Dispositivo que pode iniciar e controlar uma transferência de dados 
(exemplos: Processador, Módulo de I/O com DMA)
• Bus Slave – Dispositivo que só responde a pedidos de transferências de dados,
i.e., não tem capacidade para iniciar uma transferência 
(exemplos: Memória, Módulo de I/O sem DMA)
• Barramento de um só Master: só há um dispositivo no barramento 
com capacidade para iniciar e controlar transferências de informação
• Barramento Multi-Master: mais que um dispositivo capaz de iniciar
e controlar transferências de informação (exemplos: vários CPUs,
1 ou mais controladores de DMA, um ou mais módulos de I/O com DMA)

(1) Barramento em paralelo
    • Este tipo de barramento é constituído por vários fios de dados, sendo que
    cada fio é partilhado por um conjunto de dispositivos ligados ao barramento.
        - Estes fios inclem:
            - Barramento de dados:
                - Suporta a transmissão de dados entre os dispositivos.
                - O número de linhas deste barramento define a largura do barramento e
                é um fator determinante para a velocidade de transmissão de dados.
            - Barramento de endereços:
                - Especifica o endereço do dispositivo que vai transmitir ou receber
                - O número de linhas deste barramento define o número máximo de
                dispositivos que podem ser ligados ao barramento, ou seja, define o
                número máximo de endereços que podem ser atribuídos aos dispositivos
                (2^n, onde n é o número de linhas do barramento).
            - Barramento de controlo
                - Conjunto de sinais que especificam o tipo de operação a realizar,
                sinalizam eventos e controlam o fluxo de dados.
    
    • A transmissão paralela, com relógio comum, a débitos elevados 
    coloca problemas de vária ordem, nomeadamente:
        - Diferenças de comprimento dos fios de dados,
        logo diferenças de tempo de propagação dos sinais
        - Controlo do tempo de "skew" (diferença de tempo de propagação)
        - Dificuldade em anular a interferência entre fios adjacentes
        - Interferência mútua entre fios adjacentes ("crosstalk")
        - Elvado número de fios necessários para a implementação do barramento
        - Fichas de ligação volumosas e caras

(2) Barramento em série
    • Os barramentos série são constituídos por um único fio de dados.
    • Os dados são transmitidos em série, bit a bit, ao longo do fio de dados.
    • As vantagens ao nível físico são:
        - Simplificação da implementação do barramento, pois não é necessário
        sincronizar os sinais de relógio entre os dispositivos.
        - Redução do número de fios necessários para a implementação do barramento.
        - Redução do número de componentes necessários para a implementação do barramento.
        - Possibilidade de transmissão a maiores distâncias.
        - Possibilidade de transmissão a maiores velocidades.
    • Tipos de comunicação série:
        • Simplex: comunicação num único sentido, (TX->RX)
            - Exemplo: teclado, sensores
        • Half-duplex: comunicação nos dois sentidos, mas não simultaneamente
            - Exemplo: walkie-talkie
        • Full-duplex: comunicação nos dois sentidos, simultaneamente
            - Exemplo: telefone, Ethernet, USB

    • Diz-se que se está na presença de um barramento em série sempre que só exista
    um fio de dados, independentemente do número de fios de controlo e de endereços.
        - O sincronismo entre os dispositivos é feito através de um sinal de relógio comum,
        ou de relógios independentes entre emissor/receptor.
            - Caso sejam distintos, é necessário um mecanismo de sincronização entre os
            relógios dos dispositivos, para que a amosragem dos dados seja feita de forma
            correta.
    
    • Transmissão síncrona
        - O sinal de relógio é transmitido de forma explícita, através de um sinal adicional,
        ou na codificação dos dados.
        - O transmitor e receptor estão sincronizados pelo sinal de relógio.
        - Quando o relógio não é transmitido explicitamente, o relógio do receptor é
        recuperado a partir das transições de nível lógico na linha de dados.
    • Transmissão assíncrona
        - Não é usado relógio na transmissão dos dados, nem há recuperação do relógio
        na receção.
        - É necessário acrescentar bits de controlo para permitir a sincronização entre
        o transmitor e o receptor.
            - Exemplo: start bit, stop bit.
    
    • Técnicas de sincronização do relógio
        • Transmissão assíncrona:
            - Relógio explicito do transmissor
                - Exemplo: SPI
            - Relógio explíctio do receptor
            - Relógio explíctio mutuamente-sincronizado
                - Exemplo: I2C
            - Relógio codificado (self-clocking)
                - Exemplo: USB, Ethernet
        • Transmissão síncrona:
            - Relógio implícito
                - Exemplo: RS-232, CAN

    • Sincronização de relógio
        • Relógio explícito do transmissor
            - O transmissor envia os dados e informação de relógio em linhas separadas.
            - A linha de relógio pode ser vista como um sinal "Valid"

        • Relógio explícito do receptor
            - O receptor envia os dados e informação de relógio em linhas separadas.
            - A linha de relógio pode ser vista como um sinal "Valid"

        • Relógio explícito mutuamente-sincronizado (clock-strecthing)
            - O transmissor e recettor sincronizam-se mutuamente.

        • Relógio codificado (self-clocking)
            - O relógio é codificado nos dados.
            - O receptor recupera o relógio a partir dos dados.
            - Exemplo: codificação Manchester, em que a informação transmitida é resultante
            do "xor" entre o sinal de relógio e os dados.
            
        • Relógio implícito
            - Os relógios são locais e independentes.
            - O relógio do recetor é sincronizado ocasionalmente com o do transmissor,
            através de bits de sincronização.
            - Entre instantes de sincronização o desvio dos relógios depende da precisão
            dos osciladores locais.
            - Exemplo: RS-232

    • Transmissão de dados 
        • byte oriented transmission
            - O envio de um byte é a operação atómica do barramento.
            - Cada byte é encarado como independente dos restantes.
            - Não há restrições temporais para aa transmissão sequencial de bytes.
            - Alguns bytes podem estar reservados para estruturar a informação.
            - Exemplo: RS-232
    
    • Transmissão de dados 
        • Bit oriented transmission 
            A informação é organizadas em tramas (sequências de bits intercalada entre 
            duas situações de meio livre).
            - As tramas são constituídas por um número fixo de bits.
            - As tramas podem conter campos com diferentes funções:
                - Sincronização: sinalização do início e fim da trama
                - Arbitragem de acesso ao meio (em barramentos multi-master)
                - Identificação: Diversas formas possíveis:
                    - Quem produz
                    - Qual o destino
                    - Qual o tipo de informação
                    - etc
                - Quantidade de informação transmitida
                - Dados
                - Deteção de erros
            
            Exemplo de estrutura de uma trama 
                  |‾‾‾‾‾‾‾‾|‾‾‾‾|‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾|‾‾‾‾‾|‾‾‾‾‾‾‾‾|
            ------| Header | ID | Control | Data | CRC | Footer |------
            ↑     |________|____|_________|______|_____|________|    
        Barramento <--H --> <I-> <---C---> <-D--> <-R-> <--F--->                  
           idle      

            Exemplo de transmissão orientada ao bit: barramento CAN ("Controller Area Network")
                - Header e Footer: 1 bit de início e 1 bit de fim
                - Data: campo de dados
                - CRC ("Cyclic Redundancy Check"): código de deteção de erros
                    - Uma forma simples de CRC consiste em somar todos os bits da trama
                    e transmitir o resultado no campo CRC.
                    - O recetor soma todos os bits da trama e compara o resultado com o
                    valor recebido no campo CRC.
                - ID: identificação do dispositivo que produz a trama
                - Control: campo de controlo
                    - Exemplo: número de bytes transmitidos

    • Comunicação ponto a ponto ("half-duplex" ou "full-duplex"):
        - Há dois dispositivos ligados ao barramento, um slave e um master.
        - O master é o que controla o relógio

    • Comunicação multiponto ("half-duplex"):
        - Há vários dispositivos ligados ao barramento, todos eles slaves.
        - O master é o que controla o relógio
        - O master é o que controla o acesso ao barramento
        - O master é o que controla a arbitragem de acesso ao barramento
        - O master é o que controla a deteção de colisões
        - Exemplo: barramento CAN





!!! Pergunta !!!
80. Classifique as vantagens dos barramentos série (ao nível físico)
quando comparados com barramentos paralelo:
a. ao nível da implementação 
b. ao nível da cablagem de suporte (em barramentos com fios) 
c. ao nível do custo 
d. ao nível da distância de transmissão 
e. ao nível do débito de transmissão

< Resposta >
a. ao nível da implementação 
    - Simplificação da implementação do barramento, pois não é necessário
    sincronizar os sinais de relógio entre os dispositivos.
b. ao nível da cablagem de suporte (em barramentos com fios)
    - Redução do número de fios necessários para a implementação do barramento.
c. ao nível do custo
    - Redução do número de componentes necessários para a implementação do barramento,
    logo redução do custo.
    - Redução de interferências entre fios adjacentes, logo redução do custo, pois
    não é necessário blindar os fios.
d. ao nível da distância de transmissão
    - Possibilidade de transmissão a maiores distâncias.
e. ao nível do débito de transmissão
    - Possibilidade de transmissão a maiores velocidades.

!!! Pergunta !!!
81. O que caracteriza topologicamente um barramento de comunicação série para
podermos afirmar que este é um barramento:
a. síncrono
b. assíncrono

< Resposta >
a.  - O sinal de relógio é transmitido de forma explícita, através de um sinal adicional,
    ou na codificação dos dados.
    - O transmitor e receptor estão sincronizados pelo sinal de relógio.
    - Quando o relógio não é transmitido explicitamente, o relógio do receptor é
    recuperado a partir das transições de nível lógico na linha de dados.
b.  - Não é usado relógio na transmissão dos dados, nem há recuperação do relógio
    na receção.
    - É necessário acrescentar bits de controlo para permitir a sincronização entre
    o transmitor e o receptor.


!!! Pergunta !!!
82. Nos barramentos série com comunicação síncrona, quais os métodos mais comuns 
para assegurar que os relógios de dois ou mais nós ligados ao barramento 
se mantêm sincronizados?

< Resposta >
Relógio explícito mutuamente-sincronizado (clock-strecthing)


!!! Pergunta !!!
83. Nos barramentos série com comunicação síncrona, o que entende por codificação Manchester?

< Resposta >
Codificação Manchester é uma forma de codificação self-clocking, em que a informação
transmitida é resultante do "xor" entre o sinal de relógio e os dados.
Isto permite que o recetor recupere o relógio a partir dos dados.


!!! Pergunta !!!
84. Qual a diferença entre um protocolo de comunicação série full-duplex
e um protocolo de comunicação série half-duplex?

< Resposta >
Full-duplex: comunicação nos dois sentidos, simultaneamente
Half-duplex: comunicação nos dois sentidos, mas não simultaneamente


!!! Pergunta !!!
85. Dos protocolos de comunicação série que estudou nas aulas teóricas dê exemplos de:
a. protocolos full-duplex
b. protocolos half-duplex

< Resposta >
a. protocolos full-duplex
    - Exemplo: Ethernet, USB 3.0 Super Speed, bluetooth, etc
b. protocolos half-duplex
    - Exemplo: radio, PS/2, 3.5mm audio jack, etc


!!! Pergunta !!!
86. Dos protocolos de comunicação série que estudou nas aulas teóricas
existem casos em que a transmissão é orientada ao bit e casos em que
a transmissão é orientada ao byte.
Explique sucintamente a diferença e dê exemplos de protocolos que usam cada um dos dois.

< Resposta >
Na transmissão orientada ao bit, a informação é organizadas em tramas
(sequências de bits intercalada num meio livre). Nesta
transmissão, as tramas são constituídas por um número arbitrário de bits e podem
conter campos com diferentes funções, como por exemplo, sincronização, arbitragem,
identificação, quantidade de informação transmitida, dados e deteção de erros. 
Já na transmissão orientada ao byte, o envio de um byte é a operação atómica do barramento,
não há restrições temporais para a transmissão sequencial de bytes e alguns bytes podem
estar reservados para estruturar a informação.
Exemplos de protocolos que usam transmissão orientada ao bit: barramento CAN
Exemplos de protocolos que usam transmissão orientada ao byte: RS-232



• Serial Peripheral Interface (SPI)
    • Descrição geral

        O SPI é utilizado para comunicar com uma grande variedade de dispositivos:
        - Sensores
        - Memórias
        - Conversores A/D e D/A
        - Módulos de comunicação
        - etc

        Apenas usado para ligações a curta distância
        
        Comunicação síncrona com relógio explícito do master:
            - O master controla o relógio, que é transmitido de forma explícita para
            todos os slaves.
            - Não é exigida uma precisão elevada no relógio - os bits vão sendo transferidos
            a cada transição de relógio. Isto permite usar um oscilador de baixo custo no master
            (não é necessário um cristal de quartzo).

        Fácil de implementar por hardware ou software

        Não são necessários "line drivers" (ou "transcivers") - circuitos que permitem
        converter os sinais lógicos em sinais elétricos adequados para a transmissão em
        linhas de comunicação. Os níveis lógicos correspondem aos níveis de tensão da
        alimentação do dispositivo.

        Arquitetura "Master-Slave" com ligação ponto-a-ponto
            - Só há um master
            - O master controla o relógio 
            - O master pode comunicar com vários slaves:
                - O master seleciona o slave com que quer comunicar
                - O master controla o acesso ao barramento
                - O master controla a arbitragem de acesso ao barramento
                - O master controla a deteção de colisões


        Comunicação bidirecional, full-duplex
            - Baseado em dois shift registers em série (um no master e outro no slave)
            - Em cada ciclo de relógio, um bit é transmitido em cada sentido
                • O master envia um bit para o slave na linha MOSI
                • O slave envia um bit para o master na linha MISO
            - Ao fim de N ciclos de relógio, N bits foram transmitidos em cada sentido - Data Exchange
            - Esta sequência é realizada mesmo quando é pretendida uma transmissão 
                unidiirecional (exemplo: leitura de um sensor)
                • O master envia N bits para o slave na linha MOSI
                • O slave envia N bits para o master na linha MISO
                • O master lê os N bits recebidos na linha MISO
                • O slave ignora os N bits recebidos na linha MOSI

        Sinalização:
            • SCK: sinal de relógio
                Gerado pelo master e usado para sincronizar a transmissão/receção de dados
            • MOSI: Master Output Slave Input
                Linha de dados usada pelo master para enviar dados para o slave
            • MISO: Master Input Slave Output
                Linha de dados usada pelo slave para enviar dados para o master
            • SS: Slave Select
                Linha de dados usada pelo master para selecionar o slave com que quer comunicar
                (pode haver mais do que uma linha SS)
        
            O master e slave usam a falling edge do sinal de relógio para colocarem um bit
                na linha de dados.
            O master e slave usam a rising edge do sinal de relógio para lerem um bit da
                linha de dados e colocarem o bit no shift register.

        Operação:
            • A transição negativa do relógio é usada pelo master e pelo slave para
                colocar na respetiva linha de saída um bit de informação
            • A transição positiva seguinte é usada pelo master e pelo slave para
                armazenar o bit presente na respetiva linha de entrada
            • Ao fim de oito ciclos de relógio:
                • o valor inicialmente armazenado no shift-register do master foi
                    transferido para o shift-register do slave
                • o valor inicialmente armazenado no shift-register do slave foi transferido
                    para o shift-register do master

        Arquiteturas de ligação - slaves independentes
            • Cada slave tem a sua linha SSx\, que é controlada pelo master
            • O master seleciona o slave com que quer comunicar colocando a linha SS
                do slave a "0"
            • O master pode comunicar com um slave de cada vez
            • Os sinais SDO (Serial Data Out) dos slaves (MISO) não selecionados ficam em alta impedância
            • O número máximo de slaves é limitado pelo número de linhas SS disponíveis
                no master
            • Alternativamente, pode usar-se um multiplexador para selecionar o slave,
                ultra-passando a limitação do número de linhas SS disponíveis no master

        Arquiteturas de ligação - Daisy Chain (cascata)
            • Sinal "slave select" comum, SDO/SDI ligados em cascata
            • A saída de dados de cada slave liga à entrada de dados do seguinte
            • O conjunto dos slaves é visto pelo master como um único
                dispositivo de maior dimensão
            • Se existirem 3 slaves, cada um com 8 bits de dados, o conjunto
                é visto pelo master como um único dispositivo de 24 bits de dados

        Tipos de transferências
            • O SPI funciona sempre em modo "data exchange", isto é, o
                processo de comunicação envolve sempre a troca do conteúdo dos
                shift-registers do master e do slave
            • Cabe aos dispositivos envolvidos na comunicação usar ou descartar
                a informação recebida
            • Podem considerar-se os seguintes cenários de transferência:
                • Bidirecional: são transferidos dados válidos em ambos os sentidos
                    (master -> slave e slave -> master)
                • Master -> slave (operação de escrita): master transfere dados
                    para o slave, e ignora/descarta os dados recebidos
                • Slave -> master (operação de leitura): master pretende ler
                    dados do slave; para isso transfere para o slave uma palavra com
                    informação irrelevante (por exemplo 0); o slave ignora/descarta os
                    dados recebidos

        Configuração de um master SPI
            • Antes de iniciar a transferência há algumas configurações que são
                efetuadas no master (através do seu modelo de programação) para
                adequar os parâmetros que definem a comunicação às
                características do slave com que vai comunicar:
            1. Configurar a frequência de relógio
            2. Configurar o nível lógico de repouso ("idle") do sinal de relógio
            3. Especificar qual o flanco do relógio usado para a transmissão (a
                receção é efetuada no flanco oposto). Esta configuração é feita
                em função das características do slave com o qual o master vai
                comunicar:
                • Transmissão no flanco ascendente (consequentemente, a receção
                    é feita no flanco descendente)
                • Transmissão no flanco descendente (consequentemente, a
                    receção é feita no flanco ascendente)


!!! Pergunta !!!
87. Como caracterizaria o barramento SPI no que respeita:
    a. ao tipo de ligação entre dispositivos 
    b. ao tipo de sincronização entre dispositivos 
    c. à natureza da transferência de dados (bi-direcional, unidirecional)

< Resposta >
a. ao tipo de ligação entre dispositivos 
    - Arquitetura "Master-Slave" com ligação ponto-a-ponto
b. ao tipo de sincronização entre dispositivos
    - Comunicação síncrona com relógio explícito do master
c. à natureza da transferência de dados (bi-direcional, unidirecional)
    - Comunicação bidirecional, full-duplex
    - Baseado em dois shift registers em série (um no master e outro no slave)
    - Em cada ciclo de relógio, um bit é transmitido em cada sentido
        • O master envia um bit para o slave na linha MOSI
        • O slave envia um bit para o master na linha MISO
    - Ao fim de N ciclos de relógio, N bits foram transmitidos em cada sentido


!!! Pergunta !!!
88. Suponha um sistema de medida, baseado no protocolo SPI, que recolhe periodicamente
informação proveniente de vários sensores, cada um deles com uma resolução igual (i.e. nº de bits de dados).
Determine o tempo mínimo de que o master necessita para adquirir os valores de todos os
sensores (cada um implementado num slave distinto), sabendo que:
a. o número de sensores é 20,
    a frequência de relógio é de 100KHz e a resolução dos sensores é de 16 bits
b. o número de sensores é 8,
    a frequência de relógio é de 20KHz e a resolução dos sensores é de 8 bits 
c. o número de sensores é 10,
    a frequência de relógio é de 100KHz e a resolução dos sensores é de 8 bits 
d. o número de sensores é 30,
    a frequência de relógio é de 50KHz e a resolução dos sensores é de 8 bits

< Resposta >
a.  20 sensores * 16 bits/sensor = 320 bits
    320 bits / 100KHz = 3.2ms

b.  8 sensores * 8 bits/sensor = 64 bits
    64 bits / 20KHz = 3.2ms

c.  10 sensores * 8 bits/sensor = 80 bits
    80 bits / 100KHz = 0.8ms

d.  30 sensores * 8 bits/sensor = 240 bits
    240 bits / 50KHz = 4.8ms


!!! Pergunta !!!
89. Como caracterizaria um sistema SPI entre as seguintes opções:
multi-master assíncrono; multi-master síncrono;
ponto a ponto assíncrono; ponto a ponto síncrono.

< Resposta >
É ponto a ponto, pois só há um master e um ou mais slaves.
É síncrono, pois o master controla o relógio e este é transmitido de forma explícita para
todos os slaves.


!!! Pergunta !!!
90. Diria que o protocolo SPI é adequado para ligação entre dispositivos a longas distâncias?
Justifique adequadamente a sua resposta.

< Resposta >
Não, pois este protocolo é full duplex, ou seja, há comunicação nos dois sentidos.
Ao aumentar a distância, o tempo de propagação do sinal aumenta proporcionalmente, o que
leva à diminuição da frequência de troca de bits, logo diminuição da velocidade de transmissão.


!!! Pergunta !!!
91. Numa arquitetura em que um master SPI de 8bits se encontra ligado 
a um conjunto de três slaves organizados em daisy chain como descreveria
a interligação dos principais sinais entre o master e os slaves
e qual a dimensão das palavras trocadas entre o master e o conjunto de slaves.

< Resposta >
Nesta arquitetura:
O SDO do master é ligado ao primeiro slave,
    o SDO do primeiro slave é ligado ao SDI do segundo slave,
    o SDO do segundo slave é ligado ao SDI do terceiro slave 
    e o SDO do terceiro slave é ligado ao SDI do master.
O master envia o relógio para todos os slaves.
O master envia o SS para todos os slaves, para selecionar o slave com que quer comunicar.
O número de bits trocados entre o master e o conjunto de slaves é 24 bits (8 bits * 3 slaves).

92. Descreva sucintamente qual a sequência de operações que são realizadas ao nível do master
por forma a assegurar que os seus parâmetros são adequados a realizar validamente
troca de informação com um slave a que se encontre ligado. 

< Resposta >
1. O master seleciona o slave com que quer comunicar colocando a linha SS
    do slave a "0"
2. O master ativa o sinal de relógio que vai ser usado para sincronizar a troca de informação
3. Em cada ciclo de relógio,
    a. naprimeira transição, o master coloca no MOSI o bit que quer enviar para o slave
        e lê do MISO o bit que o slave enviou para o master
    b. na segunda transição, o master lê do MISO o bit que o slave enviou para o master
        e o slave lê do MOSI o bit que o master enviou para o slave
4. O master desativa a linha SS do slave e desliga o sinal de relógio



--------------------------------------------------------------------------------------------~
--------------------------------------------------------------------------------------------


I2C – Introdução

• Desenvolvido pela Philips Semiconductors (agora NXP Semiconductors)
    - Versão 1 em 1992
    - Atualmente na revisão 7 (Outubro de 2021)
• De acordo com a NXP: "simple bidirectional 2-wire bus for efficient inter-IC control"
    - Requer apenas duas linhas
    - Implementável em hardware e/ou software
    - Desenvolvido inicialmente para controlo de subsistemas em TVs
• Transações "master-slave" com opção "multi-master" (requer arbitragem)

• Taxas de transmissão
    - Standard mode: até 100 kbit/s
    - Fast mode: até 400 kbit/s
    - Fast mode plus: até 1 Mbit/s
    - High Speed: até 3,4 Mbit/s
    - Ultra-fast mode: até 5 Mbit/s

• Dada a sua simplicidade, versatilidade e economia de recursos, o I2C
    encontra-se em diversos tipos de área de aplicação, e.g.:
    - Sensores, DACs, ADCs
    - Memória externa em microcontroladores
    - Controlo de subsistemas em eletrónica de consumo
        e.g. ajuste dos parâmetros de imagem (contraste, brilho e saturação) 
        e som em TVs, monitores, …
    - Controlo de subsistemas em terminais de telemóvel
    - Monitorização de hardware
        e.g. temperatura de CPUs e velocidade da ventoinha em motherboards
    • Interface com Real-Time Clocks

--------------------------------------------------------------------------------------------

I2C – Caraterísticas básicas

• Transferência série bidirecional, half-duplex, orientada ao byte
• As transferências envolvem sempre uma relação master/slave
• Master pode ser transmissor ou recetor ("master-transmitter" ou
    "master-receiver")
• O barramento de comunicação necessita apenas de dois fios:
    - Serial data line (SDA)
    - Serial clock line (SCL)
• Cada dispositivo ligado ao barramento é endereçável por software 
    usando um endereço único previamente atribuído
• Endereços de 7 bits ("standard mode") - 16 endereços reservados, 112 disponíveis
• Endereçamento de 10 bits também disponível
• Barramento multi-master com deteção de colisões e arbitragem,
    evitando a corrupção de informação se dois ou mais masters
    iniciarem simultaneamente uma transferência

--------------------------------------------------------------------------------------------

I2C – terminologia

• Transmitter – dispositivo que envia dados para o barramento
• Receiver – dispositivo que recebe dados do barramento
• Master – o dispositivo que inicia a transferência, gera o sinal de
    relógio e termina a transferência
• Slave – o dispositivo endereçado pelo master
• Multi-master – vários masters podem tentar, ao mesmo tempo,
    controlar o barramento sem corromper a comunicação em curso
• Arbitragem – procedimento para assegurar que, se mais do que
    um master tentar, simultaneamente, controlar o barramento,
    apenas a um é permitido continuar, sem perturbação da
    comunicação iniciada pelo master vencedor
• Sincronização – procedimento para sincronização dos sinais de
    relógio de dois ou mais dispositivos

--------------------------------------------------------------------------------------------

Masters / Slaves

• O master
    - Controla a linha SCL (Serial Clock)
    - Inicia e termina a transferência de dados
    - Controla o endereçamento dos outros dispositivos
• O slave
    - É o dispositivo endereçado pelo master
    - Pode condicionar o estado da linha SCL
• Transmissor / Recetor
    - Master ou slave
    - Um master transmissor envia dados para um slave recetor (escrita)
    - Um master recetor lê dados de um slave transmissor (leitura)

--------------------------------------------------------------------------------------------

I2C – Sinalização

Barramento a dois fios
    - Serial data line (SDA)
    - Serial clock line (SCL)

• As linhas de clock e dados de cada dispositivo são "wire ANDed"
    com os respetivos sinais do barramento
• Na ausência de bit dominante a linha respetiva está no nível lógico 1
    (Recessivo), imposto através da resistência de pull-up RP
• Este esquema permite usar "bit recessivo" (1) e "bit dominante" (0)
    para várias sinalizações
• O primeiro byte transmitido pelo master contém:
    - 7 bits: endereço do slave
    - 1 bit: qualificação da operação (RD / WR\)
• Qualificador da operação:
    - RD/WR\ = 0: o master é o transmissor (escreve dados na linha SDA)
    - RD/WR\ = 1: o master é o recetor (lê dados da linha SDA)
• Cada slave lê o endereço da linha SDA; se o endereço lido coincide
    com o seu próprio endereço:
    - comuta para o estado "transmissor" se o bit RD/WR\ for igual a "1"
    - comuta para o estado "recetor" se o bit RD/WR\ for igual a "0"

--------------------------------------------------------------------------------------------

I2C – Transferência de bits

• Um período de relógio por bit de dados
• Dados (SDA) só são alterados quando SCL = 0
• SCL = 1: dados em SDA válidos
• Transições em SDA quando SCL=1 sinalizam "condições". As
    "condições" são sempre geradas pelo master

--------------------------------------------------------------------------------------------

Símbolos (condições)
• As transações são delimitadas por dois símbolos / "condições":
    START e STOP, geradas pelo master
• As condições START/STOP são sinalizadas por meio de uma
    sequência que viola as regras normais de transferência de dados
• Condição START:
    Transição de 1->0 em SDA quando SCL = 1
• Condição STOP:
    Transição de 0->1 em SDA quando SCL = 1
• Estado do barramento:
    • Ocupado: após um START (S) ou START repetidos (Sr), até ao
        próximo STOP
    • Livre: após um STOP (P), até ao próximo START

--------------------------------------------------------------------------------------------
Transferência de dados
• A transferência é orientada ao byte sendo transmitido, em primeiro
    lugar, o byte mais significativo (MSBit)

• No início de uma transferência, o master:
    - Envia um START (S)
    - De seguida, envia o endereço do slave (7 bits) e o bit RD/WR\ (1 bit)

• Após o 8º bit (LSBit, correspondente ao bit RD/WR\):
    - O slave endereçado, responde com um ACK (0),
        se o endereço recebido corresponder ao seu endereço,
        na linha SDA, sob a forma de um bit dominante (0)
    - De seguida, o transmissor envia um byte de dados
    - O recetor responde com um ACK (0),
        se recebeu o byte de dados com sucesso,
        na linha SDA, sob a forma de um bit dominante (0)

• Este ciclo, de 9 bits, repete-se para cada byte de dados,
    até o master enviar um STOP (P)

--------------------------------------------------------------------------------------------
Transferência de dados – escrita
• Na operação de escrita, o master é o transmissor e o slave é o recetor

• O master:
    - Envia um START (S)
    - De seguida, envia o endereço do slave                 (7 bits) 
        e o bit de qualificação da operação (RD/WR\ = 0)    (1 bit)
• O slave endereçado responde com um ACK (0) na slot seguinte
• Nos 8 ciclos de relógio seguintes, o master envia um byte de dados
    e no 9º ciclo de relógio o slave responde com um ACK (0).
• Este ciclo repete-se para cada byte de dados, até o master enviar um STOP (P)

--------------------------------------------------------------------------------------------

Transferência de dados – leitura
• Na operação de leitura, o master é o recetor e o slave é o transmissor

• O master:
    - Envia um START (S)
    - De seguida, envia o endereço do slave                 (7 bits) 
        e o bit de qualificação da operação (RD/WR\ = 1)    (1 bit)
• O slave endereçado responde com um ACK (0) na slot seguinte
• O slave envia um 8 bits de dados e no 9º ciclo de relógio o master responde com um ACK (0) ou NACK (1).
• Caso o master responda com um ACK (0):
    - O slave envia um novo byte de dados e o master responde com um ACK (0) ou NACK (1).
• Caso o master responda com um NACK (1):
    - O slave não envia mais dados e o master envia um STOP (P)

• O NACK (1) é usado para indicar ao slave que o master não pretende receber mais dados

--------------------------------------------------------------------------------------------

• O slave pode forçar o alargamento da transferência, mantendo a linha SCL em nível lógico 0
    - Esta técnica é usada para permitir que o slave termine a sua operação de escrita
    - É designada por "clock stretching"
• O sinal "wait" (do slave) condiciona o estado da linha SCL do barramento:
    - "wait" = 1: o slave força a linha SCL a nível lógico 0 (dominante)
• master fica em "wait state" enquanto SCL_MASTER != SCL_IN

--------------------------------------------------------------------------------------------

Múltiplos masters

• Dois(ou mais) masters podem iniciar uma transferência em simultâneo num barramento livre
    (isto é, após um STOP)
• Tem de estar previsto um método de arbitragem para determinar qual o master que vai
    controlar o barramento e completa a sua transferência
• O master que perde o processo de arbitragem retira-se do barramento e tenta novamente
    na próxima situação de "barramento livre"
• Na gestão do acesso ao barramento é necessário:
    1. garantir que os relógios dos masters estão sincronizados
    2. um processo que defina qual o master que ganha o acesso ao barramento, ie.,
        que controla a linha SDA (arbitragem)

• A sincronização de relógios e a arbitragem são baseados na técnica
    bit dominante / bit recessivo:
    - Um bit dominante (0) sobrepõe-se a um bit recessivo (1)

--------------------------------------------------------------------------------------------

Sincronização dos relógios dos masters (linha SCL)

• Quando a linha SCL passa de 1 -> 0,
    todos os masters devem colocar a 0 o seu relógio
• Os masters mantêm o seu relógio a 0 até o seu tempo a 0 ter chegado ao fim
• Quando um master termina a contagem do tempo a 0 do seu relógio,
    liberta a linha SCL_MASTER
• Se a SCL se mantém a 0, comuta para o estado "wait",
    ficando à espera que a linha SCL volte a 1
• Logo que a linha SCL volte a 1, inicia a contagem do tempo a 1 do seu relógio
• O primeiro master a terminar o seu tempo a 1 força a linha SCL a 0
• O sinal SCL fica sincronizado com:
    - t_low determinado pelo master que terminou com o maior t_low
    - t_high imposto pelo master com menor t_high

--------------------------------------------------------------------------------------------

Arbitragem (linha SDA)

• Quando o barramento está livre ("idle"), dois ou mais masters podem iniciar uma transferência
    - Todos geram um START (S), resultando numa condição START válida no barramento
• Arbitragem é o procedimento que assegura que, se mais do que um master tenta, simultaneamente,
    controlar o barramento, apenas a um é permitido continuar, sem perturbação da comunicação
    iniciada pelo master vencedor
• A arbitragem é baseada na técnica bit dominante / bit recessivo e processa-se bit a bit.
• Por cada novo bit transmitido, quando a linha SCL está a 1 cada master compara o bit que
    enviou com o bit que está na linha SDA
    - O processo de arbitragem é perdido por um master quando o bit que enviou é recessivo (1)
        e o bit que está na linha SDA é dominante (0)
• O master que perde o processo de arbitragem:
    - retira-se do barramento, libertando a linha SDA (comuta para o modo slave)
    - tenta novamente quando o barramento passar para o estado "idle"
        (espera o STOP do master vencedor)

--------------------------------------------------------------------------------------------

!!! Pergunta !!!
93. Considere o diagrama temporal abaixo representado.
    Admita que representa a comunicação entre um master (μC) e um slave (ADC de 10 bits).

    __                  ______________          ______          ______________                                                                         ____                    ____                    ______________        _______________________      __
SDA   \                /              \        /      \        /              \                                                                       /    \                  /    \                  /              \      /                       \    /
       \______________/                \______/        \______/                \_____________________________________________________________________/      \________________/      \________________/                \____/                         \__/

    ________      __      __      __      __      __      __      __      __      __                    __      __      __      __      __      __      __      __      __      __      __      __      __      __      __      __      __      __      ____  
SCL         \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \                  /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /  \    /    
             \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \________________/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    \__/    
    /\/\/\/\     ||||    ||||    ||||    ||||    ||||    ||||    ||||    !!!!    ----  <------------>  ****    ****    ****    ****    ****    ****    ****    ****    ++++    ****    ****    ****    ****    ****    ****    ****    ****    ++++     /\/\          
      Start      Add0    Add1    Add2    Add3    Add4    Add5    Add6   Rd/Wr\ Ack/NAck  CLK_STRETCH   Bit0    Bit1    Bit2    Bit3    Bit4    Bit5    Bit6    Bit7  Ack/NAck  Bit0    Bit1    Bit2    Bit3    Bit4    Bit5    Bit6    Bit7  Ack/NAck   Stop
                                                                                (Ack)                                                                                 (Ack)                                                                   (NAck)


a. Qual o endereço do elemento slave (ADC)?
b. Estamos perante uma operação de escrita ou de leitura?
c. Quantos ACKs são gerados pelo slave?
d. Quantos ACKs são gerados pelo master?
e. Quantos NACKs são gerados? Por quem?
f. Qual o valor (expresso em hexadecimal) que foi fornecido pela ADC ao μC,
    sabendo que este começa sempre pelo MSBit?
g. Quantas situações de clock stretch são gerados nesta transação?
   Por quem?
h. Supondo que a frequência do relógio é de 1MHz e
    que o stretch corresponde a dois ciclos de relógio, qual a duração total da transação?

< Resposta >
a. 0b0110101 = 0x35
b. Leitura. O master é o recetor (lê dados do slave). Podemos ver isso pelo bit RD/WR\ = 1.
c. 1, representado por "----" no diagrama.
d. 1. Representado pelo primeiro "++++" no diagrama
e. 1, pelo master. Representado pelo segundo "++++" no diagrama
f. 0b10_1001_1011 = 0x29B. Como o ADC tem 10bits, tem de enviar 2 tramas de 8 bits.
g. 1, pelo slave
h.  T = 1 / 1MHz = 1us
    clock_stretch = 2 * T = 2us
    handshake = (7 (address bits) + 1 (RD/WR\ bit) + 1 (ACK bit)) * T = 9us
    data = 2 * (8 (data bits) + 1 (ACK bit)) * T = 18us
    total = clock_stretch + handshake + data = 29us (DUVIDA, o start e stop contam?)


!!! Pergunta !!!
94. Descreva sucintamente, no protocolo I2C, como é realizado o endereçamento/seleção
do dispositivo a quem é destinada a mensagem ou de quem se pretende obter informação.

< Resposta >
O master envia um START (S) e de seguida envia um um byte, com um endereço de 7 bits e um bit de qualificação da operação (RD/WR\).
Caso o master queira mandar dados para o slave, o bit RD/WR\ = 0.
Caso o master queira obter dados do slave, o bit RD/WR\ = 1.


!!! Pergunta !!!
95. Quantas linhas (físicas) compõem um barramento I2C? Qual a sua designação e finalidade?

< Resposta >
São 2, o SDA e o SCL.
O SDA, Serial Data Line, é utilizado para enviar informação entre os dispositivos.
O SCL, Serial Clock Line, é utilizado para sincronizar a transmissão de informação entre os dispositivos.


!!! Pergunta !!!
96. No protocolo I2C em que condições se considera que o barramento de comunicação está livre?

< Resposta >
O barramento de comunicação, ou seja, as linhas SDA e SCL, estão livres após um STOP (P), até ao próximo START (S).
Enquanto o barramento está livre, ambas as linhas estão a 1.
O STOP (P) é uma transição de 0->1 em SDA quando SCL = 1.
O START (S) é uma transição de 1->0 em SDA quando SCL = 1.


!!! Pergunta !!!
97. Descreva sucintamente, no protocolo I2C, quem é responsável pela geração do sinal de relógio e como é possível
assegurar a sincronização do mesmo entre master e slave

< Resposta >
O master é o responável pela geração do sinal de relógio, que é enviado pela linha SCL,
    para sincronizar a transmissão de informação entre os dispositivos.
Como é um barramento multi master, é necessário assegurar que os relógios dos masters estão sincronizados.
    Para isso, quando a linha SCL passa de 1 -> 0, todos os masters devem colocar o seu relógio a 0.
    Os masters mantêm o seu relógio a 0 até o seu tempo a 0 ter chegado ao fim.
    Quando um master termina a contagem do tempo a 0 do seu relógio, liberta a linha SCL_MASTER.
    Se a SCL se mantém a 0, comuta para o estado "wait", ficando à espera que a linha SCL volte a 1.
    Logo que a linha SCL volte a 1, inicia a contagem do tempo a 1 do seu relógio.
    O primeiro master a terminar o seu tempo a 1 força a linha SCL a 0.
    O sinal SCL fica sincronizado com:
        t_low determinado pelo master que terminou com o maior t_low
        t_high imposto pelo master com menor t_high


!!! Pergunta !!!
98. Descreva sucintamente, no protocolo I2C, o processo de arbitragem no acesso ao barramento quando dois ou mais
masters tentam aceder simultaneamente ao mesmo.

< Resposta >
Quando o barramento está livre ("idle"), dois ou mais masters podem gerar um START (S) em simultâneo.
A arbitragem, baseada em bit dominante / bit recessivo, processa-se bit a bit. Isto é, por cada novo bit transmitido,
    quando a linha SCL está a 1 cada master compara o bit que enviou com o bit que está na linha SDA.
    O processo de arbitragem é perdido por um master, quando o bit que enviou é recessivo (1) e o bit que está na linha SDA é dominante (0).
O master que perde o processo de arbitragem:
    1. retira-se do barramento, libertando a linha SDA e comuta para o modo slave (DUVIDA, o master pode ser slave?)
    2. tenta novamente quando o barramento passar para o estado "idle" (espera o STOP do master vencedor)


!!! Pergunta !!!
99. No protocolo I2C, os bits que circulam no barramento têm uma característica que os distingue dos bits normalmente
gerados à saída de um circuito digital convencional. Como designa, no I2C, cada um dos dois estados lógicos, e
qual a sua utilidade para o funcionamento do barramento.

< Resposta >
Os estados do barramento são designados por OCUPADO e LIVRE.
Quando um master envia um START (S), o barramento passa para o estado OCUPADO.
Quando um master envia um STOP (P), o barramento passa para o estado LIVRE.
Isto é útil para saber se um master pode iniciar uma transferência.


!!! Pergunta !!!
100. O esquema e o diagrama temporal mostrados abaixo exemplificam a interligação entre um master e um slave e a
forma como o slave pode alterar o período do sinal de relógio gerado pelo master.
    1. Descreva os princípios de funcionamento envolvidos neste processo,
        justificando por que razão esta solução funciona.
    2. Apresente uma razão pela qual esta método pode ser particularmente interessante numa dada arquitetura.

                           <-WAIT-><XX> XX => Tempo a '1' do relógio do master      
              _____        ____________             .
clock master       \      /            \       
(SCL_MASTER)        \____/              \__________
                                                    .
                      _____________          ______
wait                 /             \        /
(slave)       ______/               \______/
                                                    .
              ______                _______
SCL                 \              /       \
                     \____________/         \_______
                                                    .
< Resposta >
1. O slave força a linha SCL a 0, colocando o sinal "wait" a 1.(*1)
    O master fica em "wait state" enquanto SCL_MASTER != SCL_IN.
    Logo que a linha SCL volte a 1, o master inicia a contagem do tempo a 1 do seu relógio.
    O primeiro master a terminar o seu tempo a 1 força a linha SCL a 0.
    
(*1) Na implementação física, o sinal "wait=1" fecha o interruptor que liga a linha SCL ao ground.
    Assim, o master não consegue colocar a linha SCL a 1, pois esta está ligada ao ground.
    Quando o slave coloca o sinal "wait=0", o interruptor abre e a linha SCL fica livre para ser controlada pelo master.
    O master força a linha SCL a 0, com o sinal "wait=0", pelo mesmo processo descrito anteriormente.

2. Este método, de clock stretching, permite ao slave processar os dados antes de enviar a próxima trama de dados.
    Isto é particularmente interessante em arquiteturas em que o slave é um dispositivo relativamente lento,
    como por exemplo um sensor de temperatura, que necessita de algum tempo para fazer a amostragem.


--------------------------------------------------------------------------------------------
********************************************************************************************
--------------------------------------------------------------------------------------------
********************************************************************************************
--------------------------------------------------------------------------------------------


Barramento CAN (Controller Area Network) – Introdução

• Desenvolvido em 1991 (versão 2.0) pela Bosch para simplificar as
    cablagens nos automóveis
• Utiliza comunicação diferencial em par entrançado
• Taxas de transmissão até 1 Mbit/s
• Adequado a aplicações de segurança crítica; elevada robustez
• Tolerância a interferência eletromagnética
• Capacidade de detetar diferentes tipos de erros
• Baixa probabilidade de não deteção de um erro de transmissão (4.7 x 10^-11)
• Atualmente usado num leque muito variado de aplicações
• Comunicação entre subsistemas de um automóvel
• Aviónica, Aplicações industriais, Domótica, Robótica
• Equipamentos médicos, ...

--------------------------------------------------------------------------------------------
Características fundamentais

• Transmissão em "broadcast": a informação enviada pelo transmissor
    pode ser recebida por todos os nós ao mesmo tempo
• Comunicação bidirecional "half-duplex"
• A informação produzida é encapsulada em tramas
• O CAN é um barramento "multi-master": qualquer nó do barramento
    pode produzir informação e iniciar uma transmissão
• Uma vez que dois ou mais nós podem querer aceder
    simultaneamente ao barramento para transmitir, tem que haver
    uma forma de arbitrar o acesso ao meio
• No CAN cada mensagem tem um ID único que identifica a natureza
    do seu conteúdo; esse ID determina também a prioridade da
    mensagem e, consequentemente, a prioridade no acesso ao
    barramento

• Comprimento máximo do barramento
    _______________________________________________________________________________________
    | 1 Mbit/s | 500 kbit/s | 250 kbit/s | 125 kbit/s | 50 kbit/s | 20 kbit/s | 10 kbit/s | <- Taxa de transmissão
    |------------------------------------------------------------------------------------ |
    |   30m    |    100m    |    250m    |    500m    |   1000m   |   2500m   |   5000m   | <- Comprimento máximo do barramento
    |------------------------------------------------------------------------------------ |
    |   1us    |    2us     |    4us     |    8us     |   16us    |   50us    |   100us   | <- Tempo máximo de propagação do sinal
    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯     

• Sincronização de relógio:
    - Relógio implícito (comunicação assíncrona,
        i.e. não há transmissão do relógio 
        - o transmissor e o recetor têm relógios locais independentes)

• Transmissão orientada ao bit

• Barramento série "multi-master"
    - Diversos nós trocam mensagens encapsuladas em tramas

• Paradigma produtor-consumidor / Transmissão em "broadcast"
    - Identificação do conteúdo da mensagem
        (não existe identificação do nó de origem ou de destino)

• Capacidade de Remote Transmission Request

• Correção de erros baseada em retransmissão

--------------------------------------------------------------------------------------------
Aplicações
     __________      __________      __________      __________      __________    
    |  Engine  |    |Suspension|    | Traction |    | Gearbox  |    |Anti-skid |
    | Control  |    | Control  |    | Control  |    | Control  |    | Breaking |
    |__________|    |__________|    |__________|    |__________|    |__________|
          |_______________|_______________|_______________|_______________|
            High Speed CAN Bus      ______|______    Max 1 Mbit/s
                                   |Body Control |
                                   |   System    |
                                   |(CAN Gateway)|                                              
                                   |_____________|                                                            
            Low Speed CAN Bus             |          Max 33.3 kbit/s
          --------------------------------|--------------------------------  
          |               |               |               |               |
    ______|_____     _____|_____     _____|_______   _____|____      _____|_____
   |Front Lights|   | Instrument|   |Seat Control | |  Door    |    |Rear Lights|                         
   | Control    |   | Cluster   |   | ___________ | |  Control |    |  Control  |                            
   |____________|   |___________|   ||  Mirror   || |__________|    |___________|
                                    || Adjustors ||
                                    ||___________||
                                    |_____________|<--- Single-Wire CAN Bus
                                                        Max 33.3 kbit/s 
                                  
--------------------------------------------------------------------------------------------
Topologia da rede e codificação

• Comunicação diferencial, par entrançado

• Na transmissão, o "transceiver" transforma o nível lógico presente
    na linha Tx em duas tensões e coloca-as nas linhas CAN_H e CAN_L

• Na receção, o "transceiver" compara as tensões nas linhas CAN_H e
    CAN_L e o resultado é enviado através da linha Rx
    para o controlador CAN

--------------------------------------------------------------------------------------------
Codificação

• Codificação NRZ (Non-Return-to-Zero)
    bit recessivo (1) -> CAN_H = CAN_L
    bit dominante (0) -> CAN_H != CAN_L
• Bit stuffing
    - Por cada 5 bits consecutivos iguais, é inserido um bit de polaridade oposta
        Por exemplo:
            000000 -> 0000010
            111111 -> 1111101
    - O bit stuffing é feito pelo transmissor e desfeito pelo recetor
    - O bit stuffing é transparente para o controlador CAN
    - O bit stuffing é feito apenas nos dados, não é feito nos campos
        de controlo da trama
    - Garante um tempo máximo entre transições da linha de dados,
        assegurando que há transições suficientes para manter sincronizados
        os instantes de amostragem de dados em cada um dos nós

--------------------------------------------------------------------------------------------
Formato da trama de dados (CAN 2.0A)

|Bus  | SOF |   Arbitration  |  Control  |      Data      |  CRC  |  ACK  |  EOF  | Inter-  |
|Idle |     |      Field     |   Field   |     Field      | Field | Field |       | mission |
       1bit       12 bits        6 bits       0-8 bytes    16 bits  2 bits  7 bits  3 bits

• SOF (1 bit) - Start of Frame
    - Bit dominante (0) que indica o início de uma trama
    - Usado para sincronização dos instantes de amostragem dos nós recetores

• Arbitration
    - ID (11 bits) - Identifier
        - Identifica o conteúdo da mensagem e também a prioridade da mensagem
            - Campo de 11 bits que contém o ID da mensagem
            - O ID é transmitido pelo nó transmissor e comparado pelos nós recetores
                com o seu próprio ID
            - O nó com o ID mais baixo tem prioridade sobre os outros
    
    - RTR (1 bit) - Remote Transmission Request
            - Bit dominante (0) indica que a mensagem contém um pedido de transmissão
            - Bit recessivo (1) indica que a mensagem contém dados
            - O RTR é transmitido pelo nó transmissor e comparado pelos nós recetores
                com o seu próprio RTR
            - O nó com o RTR mais baixo tem prioridade sobre os outros

• IDE (1 bit) - Identifier Extension
        - Bit dominante (0) indica que o campo de identificação tem 11 bits,
            trama standard CAN 2.0A
        - Bit recessivo (1) indica que o campo de identificação tem 29 bits,
            trama extended CAN 2.0B

• r0 (1 bit) - Reservado
        - Bit recessivo (1) reservado para uso futuro

• DLC (4 bits) - Data Length Code
        - Indica o número de bytes de dados que a mensagem contém
        - O DLC é transmitido pelo nó transmissor e comparado pelos nós recetores
            com o seu próprio DLC
        - O nó com o DLC mais baixo tem prioridade sobre os outros

• Data (0-8 bytes)
    - Contém os dados da mensagem
    - O número de bytes de dados é indicado pelo campo DLC
    - MSBit primeiro (/byte)

••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
• Standard Frame Formart (SFF)                                             •
•   | SOF | Identifier | RTR | IDE | r0 | DLC |        Data        | ...   •
•    <---- 11 bit ----> <-- Control  --> <--- Data Field --->              •
•        Identifier          Field                                         •
••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••

• CRC (16 bits) - Cyclic Redundancy Check
    - O CRC é transmitido pelo nó transmissor
    - Usado para deteção de erros
        - O nó recetor calcula o CRC da trama recebida e compara-o com o CRC recebido
        - Se os valores forem diferentes, o nó recetor rejeita a trama
        - Se os valores forem iguais, o nó recetor aceita a trama
    - Último bit é o CRC delimiter, bit recessivo (1)

• ACK (2 bits) - Acknowledge
    - Validação da trama (ACK slot)
    - Recessivo (produtor)
    - Dominante (1+ consumidor)

• EOF (7 bits) - End of Frame
    - Terminação da trama (7 bits recessivos)

• IFS (3 bits) - Inter-Frame Space
    - Espaço entre tramas (3 bits recessivos ou mais)

--------------------------------------------------------------------------------------------
Tipos de tramas

• Trama de dados (Data Frame)
    - Usada no envio de dados de um nó produtor para o(s) consumidor(es)
    - Nesta trama, o campo RTR é dominante (0)

    | SOF | Identifier | RTR | Control Field | Data Field | CRC | ACK | EOF | IFS |

• Trama de pedido de transmissão (Remote Trasnmission Request Frame)
    - Enviada por um nó consumidor para solicitar dados a um nó produtor
    - Nesta trama, o campo RTR é recessivo (1)
    
    | SOF | Identifier | RTR | Control Field | CRC | ACK | EOF | IFS |

• Trama de erro (Error Frame)
    - Usada para reportar um erro detetado
    - Esta trama sobrepõe-se a qualquer outra transmissão em curso

    | SOF | Identifier | RTR | Control Field | Data Field | 6 dominant bits | 8 recessive bits | IFS |
                                                           <- Error Frame -> <Error  Delimiter>

• Trama de sobrecarga (Overload Frame)
    - Usada para atrasar o envio da próxima trama
        - O nó produtor envia esta trama quando não consegue enviar a próxima trama
            dentro do tempo de inter-frame space
    - Deve iniciar-se durante os dois primeiros bits do IFS 

    |IFS| 6 dominant bits |  8 recessive bits  | IFS |
         <--  Overload --> <Overload Delimiter>

--------------------------------------------------------------------------------------------
Deteção de erros

São usados vários métodos de deteção de erros.
Se a receção de uma trama falha em qualquer um deles,
    a trama é rejeitada e é gerada uma trama de erro,
    que força a retransmissão da trama original.


• CRC Error
    - O CRC calculado pelo nó recetor é diferente do CRC recebido

• Acknowledge Error
    - O nó recetor não recebeu um ACK (0) no ACK slot
        Isto significa que a trama não foi recebida por nenhum nó da rede
        (ou seja, não foi recebida por nenhum nó com o mesmo ID)

• Form Error
    - Esta verificação apenas é feita pelo nó recetor
    - O nó recetor verifica se o número de bits recessivos na trama
        é igual ao número de bits recessivos esperados:
            7 bits recessivos no EOF 
            delimitador CRC recessivo
            delimitador ACK recessivo
    
• Bit Error
    - Cada bit transmitido é analisado pelo produtor da mensagem
        - Se o bit transmitido for diferente do bit recebido, é gerado um erro
        (exceções: identificador e ACK)

• Stuffing Error
    - Após 5 bits consecutivos iguais, se não for recebido um bit de polaridade oposta,
        é gerado um erro

--------------------------------------------------------------------------------------------
Arquitetura típica de um controlador CAN
    ___________________________________________________________________________
   |  ______________________                        ___________      _____     |
Tx | | Protocol Controller: |                      | Transmit  |    |     |    |
<--|-| data encapsulation   |                      | Message   |    | CPU |    |
   | | frame coding         |<---------------------| Buffer    |<===|     |    |
   | | error detection      |     ____________     |___________|    |     |    |
   | | error signaling      |    |            |     ___________     |INT- |<===|===>
   | | acknowledgement      |    | Hardware   |    | Receive   |    | ER- |    |
Rx | | bit encoding         |--> | Acceptance |--->| Message   |===>| FA- |    |
-->|-| synchronization      |    | Filter     |    | Buffer    |    |  CE |    |
   | |______________________|    |____________|    |___________|    |_____|    |
   |___________________________________________________________________________|

• O controlador CAN implementa o protocolo em hardware
• O "CPU interface" assegura, tipicamente, a comunicação com o CPU
    de um microcontrolador (registos de controlo, estados e dados - buffers)
• O "hardware acceptance filter" filtra as mensagens recebidas com base no seu ID.
    Por programação, é possível especificar quais os IDs das mensagens que
    serão copiadas para o "Receive Message Buffer"
    (i.e. que serão disponibilizadas ao microcontrolador)
• Este mecanismo de filtragem ao descartar mensagens não relevantes
    reduz a carga de processamento do microcontrolador

--------------------------------------------------------------------------------------------
Filtros de aceitação de mensagens e máscaras

• O CAN é um barramento de tipo "broadcast"
    - Todas as mensagens são recebidas por todos os nós e só um dos nós
        pode mandar uma mensagem de cada vez

• O controlador CAN de cada nó lê todas as mensagens que circulam no barramento
    e coloca-as num registo temporário (Receive Message Buffer)

• Logo que uma mensagem válida é recebida no MAB, é aplicado um mecanismo de filtragem
    para determinar se a mensagem deve ser copiada para o Receive Message Buffer,
    as mensagens que não passam no filtro são descartadas

• A filtragem é feita por verificação dos bits do identificador da mensagem
    com os bits de um registo de aceitação (Acceptance Filter Register)

• O mecanismo de filtragem é constituido por um conjunto de filtros e máscaras:
    na sua forma mais simples, a mensagem só é copiada para o buffer de receção
    se o identificador da mensagem igualar um dos filtros de aceitação
    (previamente configurados por software)

• As máscaras fornecem flexibilidade adicional ao permitir definir
    quais os bits do identificador que têm que ser iguais aos definidos no filtro
    e quais os que são aceites incondicionalmente

_______________________________________________________
| Mask bit n | Filter bit n | Msg ID bit n | A/R bit n |
|------------|--------------|--------------|-----------|
|      0     |       x      |       x      |   Accept  |
|      1     |       0      |       0      |   Accept  |
|      1     |       0      |       1      |   Reject  |
|      1     |       1      |       0      |   Reject  |
|______1_____|_______1______|_______1______|___Accept__|

• ACCEPT = ACCEPT10 && ACCEPT9 && ... && ACCEPT0
• Se ACCEPT = 1, a mensagem é copiada para o buffer de receção

Exemplos (ID de 11 bits):                                       xxx xxxx xxxx
    - Máscara com o valor 0x000                                 000 0000 0000   v <- Care
        Todas as mensagens são aceites                          101 1010 1010   x <- Don't care
        
                                                                vvv vvvv vvvv     
    - Máscara com o valor 0x7FF, filtro com o valor 0x1A2       111 1111 1111     
        Apenas a mensagem com o ID 0x1A2 é aceite               001 1010 0010

                                                                vvv vvvv vvxx   
    - Máscara com o valor 0x7FC, o filtro com o valor 0x230     111 1111 1100
        Apenas as mensagens com os IDs 0x230, 0x231, 0x232,     001 0001 0000
        0x233 são aceites

--------------------------------------------------------------------------------------------
Arbitragem

• Realizada durante os campos ID e RTR (Remote Transmission Request)
• Baseada em bit recessivo / bit dominante

• O nó produtor da mensagem com o ID mais baixo tem prioridade
    sobre os outros nós e ganha o processo de arbitragem e pode
    transmitir a mensagem


--------------------------------------------------------------------------------------------
!!! Pergunta !!!
115. Como classificaria o protocolo CAN relativamente:
    a. à topologia da ligação (ponto a ponto, multi-drop, multi-master, …)
        e número de ligações físicas do barramento
    b. direccionalidade das comunicações (half duplex, full duplex, …)
    c. natureza da sincronização (síncrona com relógio explícito,
        síncrona com relógio implícito, assíncrona, …)
    d. formatação da informação (byte oriented, bit oriented, …)


< Resposta >
a.  O CAN é um barramento multi-master, com comunicação bidirecional half-duplex.
    É do tipo "broadcast", ou seja, a informação enviada pelo transmissor
        pode ser recebida por todos os nós ao mesmo tempo.
    Apenas são necessárias duas ligações físicas, uma para cada linha CAN_H e CAN_L.

b.  Half-duplex, pois a comunicação é bidirecional, mas apenas um nó pode transmitir de cada vez.

c.  Relógio implícito, pois a comunicação é assíncrona, ou seja,
        o transmissor e o recetor têm relógios locais independentes.

d. Bit oriented


!!! Pergunta !!!
116. No barramento CAN a codificação das tramas de dados utiliza a técnica de "bit stuffing".
Descreva sucintamente o motivo por que esta técnica é aplicada e em que consiste.

< Resposta >
A técnica de "bit stuffing" é aplicada para garantir que há transições
    suficientes para manter sincronizados os instantes de amostragem
    de dados em cada um dos nós.
Consiste em inserir um bit de polaridade oposta,
    por cada 5 bits consecutivos iguais.


!!! Pergunta !!!
117. No barramento CAN, na composição de uma trama de dados existe um campo de 11 bits
designado por “identifier”.
Descreva sucintamente qual a finalidade deste campo.

< Resposta >
O campo "identifier" é utilizado para identificar o conteúdo da mensagem
e também a prioridade da mensagem.
Este campo é comparado pelos nós recetores com o seu próprio ID.
O nó com o ID mais baixo tem prioridade sobre os outros.


!!! Pergunta !!!
118. É ou não é verdade que, no barramento CAN,
qualquer nó da rede pode desempenhar o papel de master?
Se sim, será possível que dois masters enviem mensagens em simultâneo? Porquê?

< Resposta >
É verdade que qualquer nó da rede pode desempenhar o papel de master.
No entanto, apenas um nó pode transmitir de cada vez, porque o barramento é do tipo "broadcast",
    ou seja, a informação enviada pelo transmissor pode ser recebida por todos os nós simultaneamente.


!!! Pergunta !!!
119. Descreva sucintamente o mecanismo através do qual, no barramento CAN,
é realizado o controlo de acesso ao meio (arbitragem) quando mais do que um master
tentam enviar mensagens em simultâneo.

< Resposta >
Neste barramento, a arbitragem é feita por verificação dos bits do identificador da mensagem
    com os bits de um registo de aceitação (Acceptance Filter Register).
O nó produtor da mensagem com o ID mais baixo tem prioridade sobre os outros nós
    e ganha o processo de arbitragem, podendo transmitir a mensagem.


!!! Pergunta !!!
120. Quando, num barramento CAN, um master envia uma trama de dados,
quantos dispositivos irão receber essa mensagem? Porquê?

< Resposta >
Todos os disposoitivos irão receber a mensagem, porque é um barramento "broadcast",
    isto porque todos os nós estão ligados ao mesmo barramento.


!!! Pergunta !!!
121. O protocolo adotado pelos barramentos CAN apresenta uma muito elevada capacidade
de detetar erros do lado dos recetores (probabilidade de não detetar um erro inferior a 4,7x10-11).
Para tal, este protocolo recorre a um total de cinco técnicas complementares para detetar erros.
Nomeie e descreva sucintamente cada uma dessas técnicas.

< Resposta >
1. Verificação do CRC (Cyclic Redundancy Check)
    O nó recetor calcula o CRC da trama recebida e compara-o com o CRC recebido.
    
2. Verificação do Acknowledge
    O nó verifica se recebeu um ACK (0) no ACK slot.
    
3. Verificação do Formato
    O nó recetor verifica se o número de bits recessivos na trama
        é igual ao número de bits recessivos esperados:
            7 bits recessivos no EOF 
            delimitador CRC recessivo
            delimitador ACK recessivo

4. Verificação Bit a Bit
    Cada bit transmitido é analizado pelo próprio emissor da mensagem.

5. Verificação de Stuffing
    A cada 5 bits iguais consecutivos, é inserido um bit de polaridade opsta.

Se a receção de uma trama falha em qualquer um destes métodos,
    a trama é rejeitada e é gerada uma trama de erro,
    que força a retransmissão da trama original.


!!! Pergunta !!!
122. Admita que, numa aplicação a usar CAN 2.0A (trama com identificador standard),
o mecanismo de aceitação de mensagens do controlador CAN foi configurado
com os seguintes valores: máscara=0x7FA, filtro=0x5C0.
Determine, nesta situação, quais os identificadores de mensagens que são aceites
e passadas ao software que está a usar o controlador.

< Resposta >
Máscara: 0x7FA = 111 1111 1010
Filtro:  0x5C0 = 101 1100 0000

Valid IDs:       101 1100 1x1x = 0x5CA + 0bx0x
                => 0x5CA, 0x5CB, 0x5CE, 0x5CF



!!! Pergunta !!!
123. Resolva novamente o problema anterior admitindo que o mecanismo
de aceitação de mensagens do controlador CAN foi configurado com os seguintes valores:
    a. máscara=0x4CC, filtro=0x088.
    b. máscara=0x7FF, filtro=0x253.
    c. máscara=0x7F0, filtro=0x0A0.

< Resposta >
a.  Máscara:0x4CC = 100 1100 1100
    Filtro: 0x088 = 000 1000 1000

     Valid IDs:     0xx 10xx 10xx = 0x088 + 0bxx00xx00xx
                 => 0x088, 0x089, 0x08A, 0x08B,
                    0x098, 0x099, 0x09A, 0x09B,
                    0x0A8, 0x0A9, 0x0AA, 0x0AB,
                    0x0B8, 0x0B9, 0x0BA, 0x0BB,
                    0x188, 0x189, 0x18A, 0x18B,
                    0x198, 0x199, 0x19A, 0x19B,
                    0x1A8, 0x1A9, 0x1AA, 0x1AB,
                    0x1B8, 0x1B9, 0x1BA, 0x1BB

b.  Máscara:0x7FF = 111 1111 1111
    Filtro: 0x253 = 010 0101 0011

     Valid IDs:     010 0101 0011 = 0x253 + 0b00000000000
                => 0x253

c.  Máscara:0x7F0 = 111 1111 0000
    Filtro: 0x0A0 = 000 1010 0000

     Valid IDs:     000 1010 0000 = 0x0A0 + 0bxxxx
                => 0x0A0, 0x0A1, 0x0A2, 0x0A3,
                   0x0A4, 0x0A5, 0x0A6, 0x0A7,
                   0x0A8, 0x0A9, 0x0AA, 0x0AB,
                   0x0AC, 0x0AD, 0x0AE, 0x0AF

--------------------------------------------------------------------------------------------
********************************************************************************************
--------------------------------------------------------------------------------------------
********************************************************************************************
--------------------------------------------------------------------------------------------

Interface RS-232C - Introdução

• RS-232C – Standard (1969) para comunicação série assíncrona
    entre um Equipamento Terminal de Dados (DTE, e.g. computador) e
    um Equipamento de Comunicação de Dados (DCE, e.g. Modem)
• Permite comunicação bidirecional, full-duplex
• Transmissão orientada ao byte
• Conheceu uma grande utilização, que se estendeu muito para além
    do seu objetivo inicial (ligar DTEs a modems)
• Com o aparecimento do USB os computadores deixaram de
    disponibilizar comunicação RS-232C
• Por ser um modo de comunicação série muito fácil de implementar e
    de programar continua a ser muito usado em microcontroladores
• Apareceram no mercado conversores USB/RS-232C que permitem a
    ligação a PCs de equipamentos que implementam RS-232C

--------------------------------------------------------------------------------------------
Sinalização

• Na sua forma mais simples, a implementação da norma RS-323C
    requer apenas 2 linhas de sinalização e 1 linha de terra:
    - TXD (Transmit Data)
    - RXD (Receive Data)
    - GND (Ground)

• Podem ser usadas linhas adicionais para protocolar a troca de informação
    entre o DTE e o DCE:
    - RTS (Request To Send)
    - CTS (Clear To Send)
    - DSR (Data Set Ready)
    - DTR (Data Terminal Ready)

    A norma original definia um total de 12 sinais, sendo 9 apenas para handshaking.

     _______                 _______
    |     Tx|-------------->|Tx     |
    |     Rx|<--------------|Rx     |
    |    GND|---------------|GND    |
    |_______|               |_______|
     Equip.1                 Equip.2

--------------------------------------------------------------------------------------------
Alguns problemas da norma RS-232C

• A nível físico (na linha de comunicação) os níveis lógicos são
    codificados com tensões simétricas

• Consumo de energia elevado

• Sinalização single-ended
    - Sinal é a diferença entre tensão num fio e commmon ground (0V)
    - Sensível a ruído eletromagnético
    - Impõe limites à velocidade de transmissão/distância

• Apenas suporta ligações ponto-a-ponto (implementações multi-ponto não standard)

• A norma era suficientemente vaga para permitir implementações proprietárias que,
    embora compatíveis com a norma, não eram interoperáveis.

--------------------------------------------------------------------------------------------
Estrutura de uma trama RS-232C

               LSBit                             MSBit  
                ↓                                  ↓
1   ____      _____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ___
0       |____|_D0__|_D1_|_D2_|_D3_|_D4_|_D5_|_D6_|_D7_|_P__|    |___
           ↑  <-------------- Data Field ------------>  ↑     ↑
         Start                                       Parity  Stop
          Bit                                          Bit    Bit
                                                    (optional)

• Parity Bit
    - Opcional
    - Paridade PAR: o bit é obtido através do XOR de todos os bits do campo de dados
        i.e. data bits - 10011000 -> parity bit: 1
    - Paridade ÍMPAR: o bit é obtido através do XNOR de todos os bits do campo de dados
        i.e. data bits - 10011000 -> parity bit: 0
    - Permite detetar erros de transmissão de um bit sempre que haja um número ímpar
        de bits errados

• Stop Bit(s)
    - Coincidem com o estado de linha inativa (idle)
    - Proporcionam um intervalo de tempo de guarda mínumo entre o envio consecutivos
        de dois valores

--------------------------------------------------------------------------------------------
Codificação dos sinais 
    Camada Física - codificação dos níveis lógicos


• Numa ligação física RS-232C, os níveis lógicos são codificados em NRZ-L
    (Non-Return-to-Zero Level)
    - Nível lógico 1 -> tensão negativa (na gama -3V a -25V)
    - Nível lógico 0 -> tensão positiva (na gama +3V a +25V)

• A codificação e descodificação da trama com estes níveis de tensão é
    assegurada por circuitos eletrónicos designados por drivers de linha (line drivers).

     __________________                          __________________
    |   ____________   |                         |   ____________   |
    |  |  Software  |  |                         |  |  Software  |  |              Driver de linha
    |  | do Sistema |  |                         |  | do Sistema |  |
    |  | Embedded   |  |                         |  | Embedded   |  |                Voltage ↑
    |  | (dedicado) |  |                         |  | (dedicado) |  |                        |
    |  |____________|  |                         |  |____________|  |                   +25V +
    |        ↑         |                         |        ↑         |                       /|
    |        ↓         |                         |        ↓         |             Nível    / |
    |    __________    |                         |    __________    |            lógico   «  |---------       -------
    |   |  Device  |   |                         |   |  Device  |   |              '0'     \ |        |       |
    |   |  Driver  |   |                         |   |  Driver  |   |                       \|        |       |
    |   |__________|   |                         |   |__________|   |                    +3V +        |       |
    |        ↑         |                         |        ↑         |                        *        |       |
    |        ↓         |                         |        ↓         |             Região     *        |       |
    |    __________    |                         |    __________    |               de   --->*--------|-------|------->
    |   |Interface |   |                         |   |Interface |   |            transição   *        |       |      Tempo
    |   |  Série   |   |                         |   |  Série   |   |                        *        |       |
    |   |__________|   |                         |   |__________|   |                    -3V +        |       |
    |        ↑         |                         |        ↑         |                       /|        |       |
    |        ↓         |                         |        ↓         |           Nível      / |        |       |
    |  __________      |                         |     __________   |          lógico     «  |        ---------
    | |  Driver  |     |                         |    |  Driver  |  |            '1'       \ |
    | | de Linha |     |                         |    | de Linha |  |                       \|
    | |__________|<-->|*|----------------------|*|<-->|__________|  |                   -25V +
    |__________________|     (|*|) - Fichas      |__________________|                        |
                                de ligação

                            
    Exemplo: 8 bits de dados, paridade par, 2 stop bit
    • A trama gerada pelo controlador de comunicação série RS-232C
        para transmitir o valor 0xA3 é:

                   D0   D1   D2   D3   D4   D5   D6   D7   P    S
    1   ----+    +----+----+              +----+    +----+    +----+----+
            |    |         |              |    |    |    |    |    
    0       +----+         +----+----+----+    +----+    +----+
             Start                                             <- Stop ->
              Bit                                                 Bits

    • A trama codificada em níveis RS-232C (isto é, à saída do driver de linha) é:

            Start                                                 Stop
             Bit   D0   D1   D2   D3   D4   D5   D6   D7   P   <- Bits ->
    +12V    +----+         +----+----+----+    +----+    +----+
            |    |         |    |    |    |    |    |    |    |
            |    |         |    |    |    |    |    |    |    |
    -12V----+    +----+----+    +----+    +----+    +----+    +----+----+

--------------------------------------------------------------------------------------------
Baudrate (taxa de transmissão)

• A baudrate é, genericamente, o número de símbolos transmitidos por segundo.
    A cada símbolo pode corresponder um ou mais bits de dados.

• A taxa de transmissão de dados bruta (gross bit rate) é o número de bits
    transmitidos por segundo (bps). (baudrate != gross bit rate)

• No caso do RS-232C, a cada símbolo está associado um único bit, logo
    baudrate e gross bit rate coincidem.

• Exemplos comuns de baudrates (bps):
    600, 1200, 4800, 9600, 19200, 38400, 57600, 115200, 230400

• No exemplo anterior, o número total de bits a serem transmitidos é 12
    - 1 start bit, 8 bits de dados, 1 bit de paridade, 2 stop bits
    - considerando um baudrate de 57600 bps, o tempo de transmissão da trama é:
        12 bits / 57600 bps = 208.3 us
    - o bit rate líquido (net bit rate) é:
        8 bits / 208.3 us = 38.4 kb/s
    - o byte rate é de:
        38.4 kbps / 8 = 4.8 kB/s

--------------------------------------------------------------------------------------------
Receção de dados

• Sincronização de relógio: relógio implicito
    - Comunicação assíncrona (i.e. não há transmissão de relógio)
    - O transmissor e o recetor têm relógios locais independentes
    - O recetor tem que sincronizar o seu relógio com o do transmissor

        Transmissor                      Recetor     
     _________________              _________________
    |    _________    |    Data    |    _________   |
    |   |    Tx   |---|------------|+->|    Rx   |  |
    |   |_________|   |            ||  |_________|  |
    |        ↑        |            ||        ↑      |
    |        |        |            ||(Sync)  |      |
    |    ________     |            ||    ________   |
    |   | CLOCK_T|    |            |L-->| CLOCK_R|  |
    |   |________|    |            |    |________|  |
    |_________________|            |________________|
    
• A sincroização do processo de receção de dados é assegurado no ínicio da receção
    de cada nova trama através da deteção do start bit
    (sinalizado pela transição de nível lógico 1 para 0, após um período de inatividade)

• Este método deve ser robusto, dentro de certos limites, a diferenças de frequência
    entre os relógios do transmissor e do recetor
    - Imprecisão na geração do relógio
    - Constante de divisão dos timers (que geram o relógio) não inteiras

• Para que a comunicação se processe corretamente, o transmissor e o receptor devem
    estar configurados com os mesmos parâmetros:
    - Estrutura da trama (número de bits de dados, paridade, número de stop bits)
    - Baudrate (relógios com a mesma frequência)

• O recetor deve sincronizar-se pelo flanco negativo do start bit
    - O recetor deve amostrar cada bit a meio do intervalo de tempo correspondente
        a um bit

    Exemplo da receção do valor 0x43, com estrutura de trama 7, O, 2
        (7 bits de dados, paridade ímpar, 2 stop bits):

       Sincronização                                                     Sincronização
             ↓                                                                 ↓
    1   -----+     +-----+-----+                       +-----+     +-----+-----+    
             |Start| D0    D1  | D2    D3    D4    D5  | D6  | Par |Stop1 Stop2|
    0        +-----+           +-----+-----+-----+-----+     +-----+           +-----+
          ↑     ↑     ↑     ↑     ↑     ↑     ↑     ↑     ↑     ↑      ↑     ↑    ↑ 
          
    (↑) <- Instante ideal de amostragem


--------------------------------------------------------------------------------------------
Sincronização

• Entre instantes de sincronização, o desvio dos relógios depende da
    estabilidade/precisão dos relógios do transmissor e do recetor

• Exemplo em que a recepção não é corretamente efetuada devido a um desvio da frequência
    dos relógios do transmissor e do recetor

     Sincronização                                                     Sincronização
             ↓                                                                 ↓
    1  +-----+     +-----+-----+           +-----+     +-----+-----+-----+-----+    
             |Start| D0    D1  | D2    D3  |  D4 |  D5 | D6    Par  Stop1 Stop2|
    0        +-----+           +-----+-----+     +-----+                       +-----+
  Real    -->   ↑   ↑   ↑   ↑   ↑   ↑   ↑   ↑   ↑   ↑   ↑ 
Sampling    Start  DO  D1  D2  D3  D4  D5  D6 Par ST1 ST2  
Instances  

       ------------------------------------------------------------------------------->
             |     |     |     |     |     |     |     |     |     |     |     |     Time                                                                
             0     6    12    18    24    30    36    42    48    54    60    66    (us)

• Neste exemplo,
    o transmissor está configurado para enviar um bit a cada 6 us (baudrate de 166.7 kbps)
    e o recetor está configurado para receber um bit a cada 4 us (baudrate de 250 kbps).
    - Ocorre erro de paridade:
        - O recetor amostra o bit de paridade com o valor 1, logo vai calcular o XOR dos
            7 bits de dados, (1 ^ 1 ^ 1 ^ 0 ^ 0 ^ 0 ^ 1) = 0,
            que é diferente do bit de paridade recebido (1).
    - Ocorre erro de framing:
        - O recetor amostra o stop_bit_1 com o valor 0, no instante 39 us, em que era
            esperado o valor 1.


• Mesmo que a frequência dos relógios do transmissor e do receptor seja a mesma,
    subsiste o erro de fase, que pode impedir a correta validação da informação
    (idealmente a meio do "tempo de bit")

• Sincronizar a fase do relógio do recetor com a do transmissor é tecnicamente
    difícil

• Em vez disso, é mais fácil gerar no recetor um relógio com uma frequência N vezes
    superior ao relógio do transmissor e sincronizar a receção a partir desse relógio
    (designado por f_LCLK)

• Por exemplo, se N = 16, o erro de fase máximo desse relógio,
    relativamente ao aparecimento do start_bit, é T/16,
    onde T é o período do relógio do transmissor (ou seja, o "tempo de bit", T_bit)

• O erro de fase máximo mantém-se até ao fim da receção da trama em questão,
    mas os instantes de validação estão bem definidos:
    - start_bit validado ao fim de 8 períodos de f_LCLK
    - restantes bits validados ao fim de cada 16 períodos de f_LCLK
            
• O relógio local (LCLK) deverá então ter, idealmente, uma frequência igual a:
    f_LCLK = N * f_TCLK onde,
    f_TCLK = 1 / T_bit é a frequência do relógio do transmissor.

• N é designado por "oversampling factor" e é um parâmetro configurável
    do recetor (tipicamente, N = 4, N = 16 ou N = 64)

• Esse relógio não é sincronizado com o sinal da linha, logo impõe um erro de fase que:
    - é tanto menor quanto maior for o oversampling factor
    - é sempre inferior a um período do relógio do transmissor, Δ_1 < T_LCLK

• Utilizando um relógio com N = 16,
    o erro de fase máximo é de 1/16 do período do relógio do transmissor, i.e. T_bit/16.

• A utilização de fatores de sobreamostragem elevados nem sempre é possível
    devido a limitações de hardware e.g.:
    - a frequência do relógio do recetor pode não ser suficientemente elevada
    - constante de divisão do timer do recetor demasiado elevada

--------------------------------------------------------------------------------------------
Sincronização - Exemplo de implementação

• Considerando um fator de oversampling (N) de 16, o tempo de bit (T_bit) equivale a:
    T_bit = 16 / f_LCLK = 16 * T_LCLK. O erro de fase máximo é de T_bit/16.

• f_SMP é a frequência de amostragem do recetor

• Usando um contador de 4 bits (com o relógio f_LCLK) como divisor de frequência por 16,
    f_SMP = f_LCLK / 16.
    Basta então fazer o reset (síncrono) desse contador quando o start_bit é detetado.

• As transições ascendentes do bit 3 do contador (MSBits) definem os instantes de amostragem.

--------------------------------------------------------------------------------------------
Sincronização - Erro do instante de amostragem

• Os erros nos instantes de amostragem podem ter duas causas distintas:
    - Erro de fase (Δ_1):
        erro cometido ao determinar o instante inicial de sincroização
    - Erro provocado por desvio de frequência (Δ_2):
        a frequência dos relógios do transmissor e do recetor não são exatamente iguais
        (e.g. tolerância dos cristais de quartzo dos osciladores, constantes de divisão
        dos timers não exatamente iguais)
        Este erro é cumulativo e proporcional ao comprimento da trama.

--------------------------------------------------------------------------------------------
Máximo desvio de frequência entre transmissor e recetor

• É comum considerar-se como zona segura de amostragem do bit:
    - Pior caso é o seguinte:
        -> cabos longos com efeito de capacitância elevado (isto faz com que
            o sinal demore mais tempo a atingir o valor lógico correspondente, C = Q/V)
        -> baudrate elevado (T_bit pequeno)
        -> +- 25% do tempo de bit, em cada lado do instante ideal de amostragem
    
    - Caso ideal:
        -> baudrate moderado (T_bit relativamente grande)
        -> +- 37.5% do tempo de bit, em cada lado do instante ideal de amostragem

• Considerando um fator de oversampling (N) de 16, o tempo de bit (T_bit) equivale a:
    T_bit = 16 / f_LCLK = 16 * T_LCLK.

• Assim, o desvio máximo admitido no instante de amostragem de um bit é entre:
    Pior caso:  ±25%   * T_bit = ±4 * T_LCLK 
    Caso ideal: ±37.5% * T_bit = ±6 * T_LCLK

• Como há um erro intrínseco máximo de 1 T_LCLK, devido ao erro de fase,
    o desvio máximo admitido no instante de amostragem de um bit é de:
    ±3 * T_LCLK (pior caso) a ±5 * T_LCLK (caso ideal)

** Quiz **
    Esta correção do erro de fase para a obtenção do
    desvio máximo aceitável é conservativa. Porquê?

    => Porque o erro de fase é sempre inferior a um período do relógio do transmissor,
        Δ_1 < T_LCLK, logo o desvio máximo aceitável é sempre inferior a 5 * T_LCLK.

• Ao contrário do erro de fase, o erro provocado por desvio de frequência é cumulativo
    e diretamente proporcional ao comprimento da trama.

• Por outro lado, é necessário garantir que o último bit da trama 
    (independentemente do comprimento da trama) seja sempre amostrado
    dentro da zona segura de amostragem, ±[3, 5] * T_LCLK,
    relativamente ao instante ideal.


••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
 Consideremos então o caso em que pretendemos amostrar uma das tramas mais longas:
    > start_bit + 8 bits de dados + bit de paridade + 1 stop_bit = 11 bits

    • Continuando a admitir que o relógio local tem um fator de oversampling de 16,
    para amostrar esta trama serão então necessários 10.5 * 16 = 168 ciclos de relógio local.

    • Assim, a máxima discrepância que poderá ser tolerada entre os relógios do transmissor
    e do recetor é de:
        Δ_T = ±3/168 = ±1.8% (pior caso) a ±5/168 = ±3% (caso ideal)


• Como vimos, a máxima discrepância que poderá ser tolerada entre os relógios do transmissor
    e do recetor é de:
    Δ_T = ±3/168 = ±1.8% (pior caso) a ±5/168 = ±3% (caso ideal) para as condições indicadas


•• Exemplo: 
    Vamos assumir que a taxa de transmissão é de 115200 bps,
        8 data bits, parity bit, 1 stop bit e N = 16.
    Para os dois casos-limite, para que a comunicação se processe sem erros, qual deve
        ser a gama de frequências de relógio do recetor?

                 1                     1
    T_LCLK = --------- => f_LCLK = -------- = 1.8432 MHz
             16*115200              T_LCLK 

                         1±(1.8/100)
    Δ_T_CLK_pior_caso = ------------- => Δ_T_CLK_pior_caso ∈ [1.811, 1.877] MHz
                          16*115200

                            1±(/100)
    Δ_T_CLK_caso_ideal = ------------- => Δ_T_CLK_caso_ideal ∈ [1.799, 1.900] MHz
                            16*115200



••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
////////////////////////////////////////////////////////////////////////////////////////////
Template de trama RS-232C

- Trama de estrutura 7, O, 2 (7 bits de dados, paridade ímpar, 2 stop bits):

    1  +-----+     +-----+-----+                       +-----+     +-----+-----+    
             |Start| D0    D1  | D2    D3    D4    D5  | D6  | Par |Stop1 Stop2|
    0        +-----+           +-----+-----+-----+-----+     +-----+           +-----+
////////////////////////////////////////////////////////////////////////////////////////////
••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••

--------------------------------------------------------------------------------------------
!!! Pergunta !!!
101. Como classificaria a interface RS-232 relativamente:
    a. topologia da ligação (ponto a ponto, multi-drop, multi-master, …) 
        e número de ligações físicas do barramento
    b. direccionalidade das comunicações (half duplex, full-duplex, …)
    c. natureza da sincronização
        (síncrona com relógio explícito, síncrona com relógio implícito, assíncrona, …)
    d. formatação da informação (byte oriented, bit oriented, …)

< Resposta >
a. Ponto-a-ponto, 2 ligações físicas (TXD, RXD) + 1 ligação de terra (GND)
b. Full-duplex, comunicação bidirecional simultânea
c. Assíncrona, com relógio implícito
d. Byte oriented, com bit de start, bits de dados, bit de paridade e bits de stop


!!! Pergunta !!!
102. Na interface RS-232, caso o desvio de frequência entre o emissor e o recetor seja elevado 
a informação recebida pode conter erros nos dados recebidos.
Indique quais os tipos de erro que podem ocorrer,
e descreva os mecanismos que permitem detetar tais erros.

< Resposta >
Erro de paridade: o bit de paridade é calculado pelo recetor e comparado com o bit de paridade recebido.
    - É calculado através do XOR (paridade PAR) ou XNOR (paridade ÍMPAR) dos bits de dados.
Erro de framing: o bit de stop é amostrado com o valor errado.
    - O(s) bit(s) de stop é(são) amostrado(s) com o valor 0, quando deveria ser 1.


!!! Pergunta !!!
103. Na interface RS-232 uma das fontes de erro, do lado do recetor,
do instante de amostragem dos vários bits é o "erro de fase".
Indique qual a metodologia que é usada para diminuir o impacto dessa fonte de erro
e explique sucintamente porque é que esse método contribui para diminuir esse erro.

< Resposta >
O erro de fase é o erro cometido ao determinar o instante inicial de sincroização,
    que é tanto menor quanto maior for o oversampling factor.
O oversampling factor é um parâmetro configurável do recetor (tipicamente, N = 4, N = 16 ou N = 64).
Este é o fator de divisão do relógio do recetor, que é usado para amostrar os bits
    da trama, e é um parâmetro configurável do recetor.
Ao usar um relógio com uma frequência N vezes superior ao relógio do transmissor
    e sincronizar a receção a partir desse relógio, o erro de fase máximo é de T_bit/16,
    onde T_bit é o período do relógio do transmissor.


!!! Pergunta !!!
104. Admita que a configuração numa comunicação RS-232 (figura abaixo) é
38400 bps, 7 bits sem paridade, 1 stop bit e fator de sobre amostragem de 64.
Calcule o valor de frequência ideal no recetor e os intervalos admissíveis dessa 
frequência para os casos limite (+-25% do tempo de bit e +-75% do tempo de bit).
Para isso calcule sucessivamente o seguinte:
    a. intervalo de validação em períodos do sinal de relógio (TLCLK) para os dois casos limite.
    b. número de períodos de relógio para amostrar a trama.
    c. variação máxima de frequência (em percentagem) para os dois casos limite.
    d. qual o intervalo de frequência que é possível usar para que não haja erros nos casos limite.

< Resposta >
    Formulário:
    T_bit = N * T_LCLK
    T_LCLK = 1 / f_LCLK = 1 / (N * f_TCLK)
    f_TCLK = baudrate
    N = 64

    a. intervalo de validação em períodos do sinal de relógio (TLCLK) para os dois casos limite.
        Pior caso: Δ_T = ±25%   * T_bit = ± 16 * T_LCLK 
        Caso ideal: Δ_T = ±37.5% * T_bit = ± 24 * T_LCLK

        Tendo em conta o erro intrínseco máximo de 1 T_LCLK, devido ao erro de fase,
        o desvio máximo aceitável no instante de amostragem de um bit é de:
        ±15 * T_LCLK (pior caso)
        ±23 * T_LCLK (caso ideal)

    b. número de períodos de relógio para amostrar a trama.
        1 start bit + 7 bits de dados + 1 stop bit = 9 bits
        (8 + (1/2)) * 64 = 544 ciclos de relógio local

    c. variação máxima de frequência (em percentagem) para os dois casos limite.
        Δ_T = ±15/544 = ±2.76% (pior caso)
        Δ_T = ±23/544 = ±4.23% (caso ideal)

    d. qual o intervalo de frequência que é possível usar para que não haja erros nos casos limite.
        T_LCLK = 1/(64 * 38400) » f_LCLK = 1 / T_LCLK = 64 * 38400 = 2457600 Hz (caso ideal)
        T_CLK = (1 ± 2.76/100) / (64 * 38400) » f_LCLK = 1 / T_LCLK ∈ [2391592; 2527355] Hz (pior caso)
        T_CLK = (1 ± 4.23/100) / (64 * 38400) » f_LCLK = 1 / T_LCLK ∈ [2356280; 2568025] Hz (caso ideal)

!!! Pergunta !!!
105. Repita o exercício anterior admitindo agora que o baudrate é 57600 bps,
a trama é composta por 8 bits com paridade par e 2 stop bits, sendo o fator de sobreamostragem de 16.

< Resposta >
    Formulário:
    T_bit = N * T_LCLK
    T_LCLK = 1 / f_LCLK = 1 / (N * f_TCLK)
    f_TCLK = baudrate
    N = 16

    a. intervalo de validação em períodos do sinal de relógio (TLCLK) para os dois casos limite.
        Pior caso: Δ_T = ±25%   * T_bit = ± 4 * T_LCLK 
        Caso ideal: Δ_T = ±37.5% * T_bit = ± 6 * T_LCLK

        Tendo em conta o erro intrínseco máximo de 1 T_LCLK, devido ao erro de fase,
        o desvio máximo aceitável no instante de amostragem de um bit é de:
        ±3 * T_LCLK (pior caso)
        ±5 * T_LCLK (caso ideal)

    b. número de períodos de relógio para amostrar a trama.
        1 start bit + 8 bits de dados + 1 bit de paridade + 2 stop bits = 11 bits
        (10 + (1/2)) * 16 = 168 ciclos de relógio local

    c. variação máxima de frequência (em percentagem) para os dois casos limite.
        Δ_T = ±3/168 = ±1.79% (pior caso)
        Δ_T = ±5/168 = ±2.98% (caso ideal)

    d. qual o intervalo de frequência que é possível usar para que não haja erros nos casos limite.
        T_LCLK = 1/(16 * 57600) » f_LCLK = 1 / T_LCLK = 16 * 57600 = 1843200 Hz (caso ideal)
        T_CLK = (1 ± 1.79/100) / (16 * 57600) » f_LCLK = 1 / T_LCLK ∈ [1810609; 1876986] Hz (pior caso)
        T_CLK = (1 ± 2.98/100) / (16 * 57600) » f_LCLK = 1 / T_LCLK ∈ [1798515; 1900206] Hz (caso ideal)

!!! Pergunta !!!
107.Considere uma UART configurada para transmitir com os seguintes parâmetros:
100.000 bps, 8 data bits, paridade ímpar e 1 stop bit.
Desenhe na figura abaixo a trama completa gerada no envio do valor 0x5A.
Indique de forma inequívoca os bits de start, de stop e de paridade

< Resposta >
0x5A = 0b01011010 

             +-----+     +-----+     +-----+     +-----+     +-----+     +-----
Tx Clock     |     |     |     |     |     |     |     |     |     |     |       
        -----+     +-----+     +-----+     +-----+     +-----+     +-----+      
        -----+           +-----+     +-----+-----+     +-----+           +----- 
Tx Data      |           |     |     |           |     |     |           |
             +-----+-----+     +-----+           +-----+     +-----+-----+
             |Start| D0  | D1  | D2  | D3  | D4  | D5  | D6  |  D7 | Par |Stop1| 


!!! Pergunta !!!
108. Um dispositivo com interface RS-232, configurado para transmitir com:
    7 bits de dados, paridade par e 2 stop bits,
produz as duas tramas representadas nos diagramas seguintes que são
recebidas por outro dispositivo RS-232 incorretamente configurado para:
    8 bits de dados, sem paridade e 1 stop bit mas com o mesmo baudrate.
Nestas circunstâncias, determine se no recetor vais ser detetado algum erro e porquê.
Caso não seja detetado nenhum erro, determine, em hexadecimal, qual o valor recebido.


-+-----+                             +-----+-----+           +-----+-----
idle   |                             |           |           |             <= Frame 1; Vista no recetor
       +-----+-----+-----+-----+-----+           +-----+-----+                       
       |Start| D0  | D1  | D2  | D3  | D4  | D5  | D6  | D7  |Stop1|

-+-----+     +-----+     +-----+-----+     +-----+           +-----+-----
idle   |     |     |     |           |     |     |           |             <= Frame 2; Vista no recetor
       +-----+     +-----+           +-----+     +-----+-----+
       |Start| D0  | D1  | D2  | D3  | D4  | D5  | D6  | D7  |Stop1|
             
< Resposta >
Para ambos os frames:
    - Como o recetor não está configurado para receber paridade, não vai detetar erros de paridade.
    - Também não é detetado erro de framing, porque o bit de stop é amostrado com o valor 1.
No frame 1:
    - O valor recebido é 0b00110000 = 0x30
No frame 2:
    - O valor recebido é 0b00101101 = 0x2D


!!! Pergunta !!!
109. Um dispositivo com interface RS232, configurado para transmitir
    8 bits de dados, paridade ímpar e 1 stop bits,
produz a trama acima (Frame 2 do exercício anterior) que é recebida por outro
dispositivo RS232 incorretamente configurado para:
    7 bits de dados, sem paridade e 1 stop bit, mas com o mesmo baudrate.
Nestas circunstâncias, determine se no recetor vais ser detetado algum error e porquê.
Caso não seja detetado nenhum erro, determine, em hexadecimal, qual o valor recebido.

< Resposta >
- Como o recetor não está configurado para receber paridade, não vai detetar erros de paridade.
- Também não é detetado erro de framing, porque o bit de stop é amostrado com o valor 1.
- O valor recebido é 0b00101101 = 0x2D
(DUVIDA: É suposto ser o mesmo valor que no exercício anterior?)


!!! Pergunta !!!
110. Um dispositivo com interface RS232, configurado para transmitir com:
    7 bits de dados, paridade par e 2 stop bits,
produz a trama seguinte que é recebida por outro dispositivo RS232
configurado com os mesmos parâmetros.
No entanto, devido a imprecisão do relógio, o baudrate efetivo do recetor é 7% inferior
ao valor do baudrate do transmissor.
Nestas circunstâncias, determine se no recetor vais ser detetado algum error e porquê. 
Caso não seja detetado nenhum erro, determine, em hexadecimal, qual o valor recebido.
       
       |Start| D0  | D1  | D2  | D3  | D4  | D5  | D6  | Par | Stop bits | 
-+-----+           +-----------+     +-----+-----+           +-----+-----+-
idle   |           |           |     |           |           |              <= Frame 1      
       +-----+-----+           +-----+           +-----+-----+                 As sent by
-------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-->  the transmitter
       0    10    20    30    40    50    60    70    80    90   100   110  Time 
                                                                            (units of time)
         ↑      ↑      ↑     ↑      ↑     ↑     ↑      ↑     ↑      ↑     ↑
        (1)    (2)    (3)   (4)    (5)   (6)   (7)    (8)   (9)   (10)  (11)  Actual sampling 
                                                                              instants by the 
                                                                              receptor
< Resposta >
Se a baudrate do receptor é 7% inferior à do transmissor, o tempo de bit do receptor é
1/0.93 = 1.0753 vezes o tempo de bit do transmissor.

Os tempos de sample são respetivamente:   Para efeitos de análise:
(1) -> 5*1.0753 = 5.3765                  [0.0, 1.6[ -> 0
(2) -> 15*1.0753 = 16.1295                [1.6, 3.3[ -> 1
(3) -> 25*1.0753 = 26.8825                [3.3, 5.0[ -> 2
(4) -> 35*1.0753 = 37.6355                [5.0, 6.6[ -> 3
(5) -> 45*1.0753 = 48.3885                [6.6, 8.3[ -> 4
(6) -> 55*1.0753 = 59.1415                [8.3,  10[ -> 5
(7) -> 65*1.0753 = 69.8945
(8) -> 75*1.0753 = 80.6475      
(9) -> 85*1.0753 = 91.4005
(10) -> 95*1.0753 = 102.1535
(11) -> 105*1.0753 = 112.9065

Assim temos os seguintes valores amostrados:
    D0(2) = 0   D4(6) = 0   Start(1) = 0
    D1(3) = 1   D5(7) = 1   Stop1(10) = 1
    D2(4) = 1   D6(8) = 1   Stop2(11) = 1
    D3(5) = 1   Par(9) = 1 

O valor transmitido é 0b0110110 = 0x36.
O valor recebido é 0b1101110 = 0x6E.
A paridade é par e existem 5 data bits a 1 (ímpar).
    Para que a paridade seja par, o bit de paridade deve ser 1, para que o número de bits a 1
        seja par. 
    O bit de paridade recebido é 1, logo não há erro de paridade.
Também não há erro de framing, porque os bits de stop são amostrados com o valor 1.
Assim, apesar do erro de frequência, não há erros na receção da trama, porém o valor recebido
    é diferente do valor transmitido.


--------------------------------------------------------------------------------------------
********************************************************************************************
--------------------------------------------------------------------------------------------
********************************************************************************************
--------------------------------------------------------------------------------------------

Device Drivers - Introdução

• O número de periféricos existentes é muito vasto:
• Teclado, rato, placas (gráfica, rede, som, etc.), disco duro, pen
    drive, scanner, câmara de vídeo, etc.
• Estes periféricos apresentam características distintas:
    - Operações suportadas: leitura, escrita, leitura e escrita
    - Modo de acesso: carater, bloco, etc.
    - Representação da informação: ASCII, UNICODE, Little/Big
        Endian, etc.
    - Largura de banda: alguns bytes/s a MB/s
    - Recursos utilizados: portos (I/O, memory mapped), interrupções,
        DMA, etc.
    - Implementação: diferentes dispositivos de uma dada classe
        podem ser baseados em implementações distintas (e.g. diferentes
        fabricantes, diferentes modelos) com reflexos profundos na sua
        operação interna

• As aplicações/Sistemas Operativos (SO) não podem conhecer todos
    os tipos de dispositivos passados, atuais e futuros com um nível de
    detalhe suficiente para realizar o seu controlo a baixo nível!
• Solução: Criar uma camada de abstração que permita o acesso ao
    dispositivo de forma independente da sua implementação

••Device driver••
    - Um programa que permite a outro programa (aplicação, SO) interagir
        com um dado dispositivo de hardware
    - Implementa a camada de abstração e lida com as particularidades do
        dispositivo controlado
    - Como o Device Driver tem de lidar com os aspetos específicos da
        implementação física, o seu fornecimento é sempre assegurado pelo
        fabricante

• Aspetos-chave:
    - Abstração, uniformização de acesso, independência entre aplicações/SO
        e o hardware

--------------------------------------------------------------------------------------------
Princípios de gerais

• O acesso, por parte das aplicações, a um device driver é diferente num
    sistema embutido e num sistema computacional de uso geral
    (com um Sistema Operativo típico, e.g. Linux, Windows, Mac OS):
        - Aplicações em sistemas embutidos acedem, tipicamente, de forma
            direta aos device drivers
        - Aplicações que correm sobre SO acedem a funções do SO 
            (system calls); o kernel do SO, por sua vez, acede aos device drivers

    +-------------------+       +-------------------+
    |     Aplicação     |       |     Aplicação     |
    +-------------------+       +-------------------+
              ↑                           ↑
              |                           |
              |                           ↓
              |                 +-------------------+
              |                 |        SO         |
              |                 |  (kernel do SO)   |
              |                 |  Ex.dev/ttyUSB0   |
              |                 +-------------------+
              |                           ↑
              |                           |
              ↓                           ↓
    +-------------------+       +-------------------+
    |   Device Driver   |       |   Device Driver   |
    +-------------------+       +-------------------+
              ↑                           ↑
              |                           |
              ↓                           ↓
    +-------------------+       +-------------------+
    |      Hardware     |       |      Hardware     |
    +-------------------+       +-------------------+

              
• O Sistema Operativo especifica classes de dispositivos e, para cada
    classe, uma interface que estabelece como é realizado o acesso a esses
    dispositivos
    - A função do device driver é traduzir as chamadas realizadas pela
        aplicação/SO em ações específicas do dispositivo
    - Exemplos de classes de dispositivos: 
        interface com o utilizador, armazenamento de massa, comunicação

    +-----------------------------------------------------------------------------------------+
    |                                       Aplicação                                         |
    +-----------------------------------------------------------------------------------------+
                    ↑                       |    ↑                |        ↑                ↑
    System Calls    ↓                       ↓    |                ↓        |                ↓     
    +-----------------------------+  +--------------------+ +--------------------+ +----------+
    |fd=open("/dev/xxx",O_RDWR,0);|  |read(fd,out_data,8);| |write(fd,in_data,8);| |close(fd);|
    +-----------------------------+  +--------------------+ +--------------------+ +----------+
                    ↑                       ↑    ↑                |        ↑                ↑
                    ↓                       ↓    |                ↓        |                ↓
    +-----------------------------------------------------------------------------------------+
    |                                       SO  kernel                                        |
    +-----------------------------------------------------------------------------------------+
                    ↑                        ↑  ↑            ↑       |             ↑
                    ↓                        ↓  |            ↓       ↓             ↓
Device        +----------+              +----------+       +-----------+     +-----------+
Driver        |xxx_open()|              |xxx_read()|       |xxx_write()|     |xxx_close()|
Routines      +----------+              +----------+       +-----------+     +-----------+    
                    ↑                        ↑  ↑            ↑       |             ↑
                    ↓                        ↓  |            ↓       ↓             ↓
    +-----------------------------------------------------------------------------------------+
    |                                       Hardware                                          |
    +-----------------------------------------------------------------------------------------+
        ---->
        data flow

--------------------------------------------------------------------------------------------
Exemplo de um device driver - Comunicação Série

• Admitindo que é fornecida uma biblioteca que apresenta a seguinte
    interface:
    void comDrv_init(int baudrate, char dataBits,
                        char parity, char stopBits);
    char comDrv_getc(void);     // read a character
    void comDrv_putc(char ch);  // write a character
    void comDrv_close(void);


• Do ponto de vista da aplicação:
    1 - Do ponto de vista funcional é relevante qual o modelo/fabricante do
        dispositivo de comunicação série?
    2 - Se o dispositivo de comunicação for substituído por outro com
        arquitetura interna distinta, sendo fornecida uma biblioteca com
        interface compatível, é necessário alterar a aplicação?

    1 - Não, pois a aplicação apenas tem de saver quais os parâmetros de
        configuração do dispositivo de comunicação série, definidos pela
        biblioteca fornecida.
    2 - Não, porque a interface da biblioteca é compatível com a interface
        anteriormente utilizada. A aplicação não tem de saber como é que a
        biblioteca implementa a interface.

--------------------------------------------------------------------------------------------
Caso de estudo
• Realização de um device driver para uma UART RS232
    (Universal Assynchronous Receiver Transmitter)
    para executar num sistema com microcontrolador (i.e., sem sistema operativo)

• Princípio de operação
    - Desacoplamento da transferência de dados entre a UART e a
        aplicação realizada por meio de FIFOs (um FIFO de transmissão e um de receção).
        Do ponto de vista da aplicação:
        * A transmissão consiste em copiar os dados a enviar para o FIFO de
            transmissão do device driver
        * A receção consiste em ler os dados recebidos que residem no FIFO de
            receção do device driver

    - A transferência de dados entre os FIFOS e a UART é realizada por
        interrupção, i.e., sem intervenção explícita da aplicação

    - Um FIFO pode ser implementado através de um buffer circular


• Princípio de operação – receção
    - "tail" - posição do buffer circular onde a rotina de serviço à interrupção
        deve escrever o próximo caracter recebido pela UART
    - "head" - posição do buffer circular de onde a função comDrv_getc() deve
        ler o próximo caracter a disponibilizar à aplicação
    - "count" - número de caracteres disponíveis para leitura pela aplicação

    * A variável "count" é um recurso partilhado. Porquê?
        => Porque é acedida pela rotina de serviço à interrupção e pela função comDrv_getc().

--------------------------------------------------------------------------------------------
Implementação - FIFO

• FIFO - Buffer circular implementado através de um array linear:
 
    +-----------------------------------------------+
    |#define BUF_SIZE 32                            |
    |    typedef struct                             |
    |    {                                          |
    |       unsigned char data[BUF_SIZE];           |
    |       unsigned int head;                      |
    |       unsigned int tail;                      |
    |       unsigned int count;                     |
    |    } circularBuffer;                          |
    |                                               |
    |    circularBuffer txb; // Transmission buffer |
    |    circularBuffer rxb; // Reception buffer    |
    +-----------------------------------------------+
    
• A constante "BUF_SIZE" deve ser definida em função das necessidades
    previsíveis de pico de tráfego.
• Se "BUF_SIZE" for uma potência de 2 simplifica a atualização dos
    índices do buffer circular (podem ser encarados como contadores
    módulo 2N e podem ser geridos com uma simples máscara)

--------------------------------------------------------------------------------------------
Implementação – Função de transmissão

• A função de transmissão, evocada pela aplicação,
    copia o caracter para o buffer de transmissão (posição "tail"),
    incrementa o índice "tail" e o contador

    +-------------------------------------------------------+
    |void comDrv_putc(char ch)                              |
    |{                                                      |
    |    while(txb.count == BUF_SIZE); // Wait while buffer |
    |                                   // is full          |
    |    txb.data[txb.tail] = ch;      // Copy character    |
    |                                   // to the buffer    |
    |    txb.tail = (txb.tail + 1)     // Increment tail    |
    |               & (BUF_SIZE-1);     // (mod BUF_SIZE)   |
    |    DisableUartTxInterrupts();    // Begin of atomic   |
    |                                   // operation        |
    |    txb.count++;                  // Increment count   |
    |    EnableUartTxInterrupts();     // End of atomic     |
    |                                   // operation        |
    |}                                                      |
    +-------------------------------------------------------+

    * O acesso à variável "count" é protegido por um mecanismo de
        exclusão mútua (desativação das interrupções durante a atualização
        do contador)

--------------------------------------------------------------------------------------------
Implementação – Função de receção

• A função de receção, evocada pela aplicação,
verifica se há caracteres no buffer de receção para serem lidos e,
caso haja, retorna o caracter presente na posição "head",
incrementa o índice "head" e decrementa o contador
    +-------------------------------------------------------+
    |int comDrv_getc(char *pchar)                          |
    |{                                                      |
    |    if(rxb.count == 0) // If buffer is empty           |
    |        return FALSE;                                  |
    |    DisableUartRxInterrupts();    // Begin of atomic   |
    |                                   // operation        |
    |    *pchar = rxb.data[rxb.head]; // Copy character     |
    |                                   // pointed by head  |
    |    rxb.count--;                  // Decrement count   |
    |    rxb.head = (rxb.head + 1)     // Increment head    |
    |               & (BUF_SIZE-1);     // (mod BUF_SIZE)   |
    |    EnableUartRxInterrupts();     // End of atomic     |
    |                                   // operation        |
    |    return TRUE;                                       |
    |}                                                      |
    +-------------------------------------------------------+
    

    * O acesso à variável "count" é protegido por um mecanismo de
        exclusão mútua (desativação das interrupções durante a atualização
        do contador)

--------------------------------------------------------------------------------------------
Implementação – Rotina de serviço à interrupção de receção

• A rotina de serviço à interrupção da receção é executada
    sempre que a UART recebe um novo caracter
• O caracter recebido pela UART deve então ser copiado para
    o buffer de receção, na posição "tail";
    a variável "count" deve ser incrementada 
    e o índice "tail" deve ser igualmente incrementado

    +-------------------------------------------------------+
    |void _int_(UART_1_VECTOR) isr_rx(void)                 |
    |{                                                      |
    |    if(IFS0bits.U1RXIF == 1) // if U1RXIF is set       |
    |    {                                                  |
    |        rxb.data[rxb.tail] = U1RXREG; // Read character|
    |        rxb.tail = (rxb.tail + 1)   // Increment tail  |
    |                   & (BUF_SIZE-1);   // (mod BUF_SIZE) |
    |        if(rxb.count < BUF_SIZE) // If buffer is not   |
    |                                  // full              |
    |            rxb.count++;        // Increment count     |
    |    }                                                  |
    |    IFS0bits.U1RXIF = 0; // Reset UART1 RX interrupt   |
    |}                                                      |
    +-------------------------------------------------------+

    * O que acontece no caso em que o buffer circular está cheio
        e a UART recebe um novo caracter?
        Como resolver esse problema?
        => O caracter recebido é perdido, porque o buffer está cheio.
        => A solução é verificar se o buffer está cheio antes de incrementar o índice "tail".

--------------------------------------------------------------------------------------------
Implementação – Rotina de serviço à interrupção de transmissão

• A UART gera, normalmente, uma interrupção de transmissão quando tiver disponibilidade
    para transmitir um novo caracter
• As tarefas a implementar na respetiva rotina de serviço à interrupção são:
    - Se o número de caracteres no buffer de transmissão for maior que 0 ("count" > 0),
        copiar o conteúdo do buffer na posição "head" para a UART
    - Decrementar a variável "count" e incrementar o índice "head"

    +-------------------------------------------------------+
    |void _int_(UART_1_VECTOR) isr_tx(void)                 |
    |{                                                      |
    |    if(IFS0bits.U1TXIF == 1) // if U1TXIF is set       |
    |    {                                                  |
    |        if(txb.count > 0) // If "count" is greater than|
    |                           // zero                     |
    |        {                                              |
    |            U1TXREG = txb.data[txb.head]; // Copy      |
    |                                           // character|
    |            txb.head = (txb.head + 1)   // Increment   |
    |                       & (BUF_SIZE-1);   // head index |
    |            txb.count--;                // Decrement   |
    |                                         // count      |
    |        }                                              |
    |        else                                           |
    |            DisableUartTxInterrupts(); // Begin of     |
    |                                        // atomic      |
    |                                        // operation   |
    |    }                                                  |
    |    IFS0bits.U1TXIF = 0; // Reset UART1 TX interrupt   |
    |}                                                      |
    +-------------------------------------------------------+

--------------------------------------------------------------------------------------------
Atualização do TX "count" - Secção crítica

• A atualização do "count" é uma operação crítica, pois é acedida
    pela rotina de serviço à interrupção e pela função comDrv_putc()

    +-------------------------------------------------------+
    |void comDrv_putc(char ch)                              |
    |{                                                      |
    |    while(txb.count == BUF_SIZE); // Wait while buffer |
    |                                   // is full          |
    |    txb.data[txb.tail] = ch;      // Copy character    |
    |                                   // to the buffer    |
    |    txb.tail = (txb.tail + 1)     // Increment tail    |
    |               & (BUF_SIZE-1);     // (mod BUF_SIZE)   |
    |    DisableUartTxInterrupts();    // Begin of atomic   |
    |                                   // operation        |
    |    txb.count++;                  // Increment count   |
    |    EnableUartTxInterrupts();     // End of atomic     |
    |                                   // operation        |
    |}                                                      |
    +-------------------------------------------------------+

    +-------------------------------------------------------+
    |void _int_(UART_1_VECTOR) isr_tx(void)               |
    |{                                                      |
    |    if(IFS0bits.U1TXIF == 1) // if U1TXIF is set       |
    |    {                                                  |
    |        if(txb.count > 0) // If "count" is greater than|
    |                           // zero                     |
    |        {                                              |
    |            U1TXREG = txb.data[txb.head]; // Copy      |
    |                                           // character|
    |            txb.head = (txb.head + 1)   // Increment   |
    |                       & (BUF_SIZE-1);   // head index |
    |            txb.count--;                // Decrement   |
    |                                         // count      |
    |        }                                              |
    |        else                                           |
    |            DisableUartTxInterrupts(); // Begin of     |
    |                                        // atomic      |
    |                                        // operation   |
    |    }                                                  |
    |    IFS0bits.U1TXIF = 0; // Reset UART1 TX interrupt   |
    |}                                                      |
    +-------------------------------------------------------+

--------------------------------------------------------------------------------------------
Atualização do RX "count" - Secção crítica

    +-------------------------------------------------------+
    |char comDrv_getc(char *pchar)                          |
    |{                                                      |
    |    if(rxb.count == 0) // If buffer is empty           |
    |        return FALSE;                                  |
    |    DisableUartRxInterrupts();    // Begin of atomic   |
    |                                   // operation        |
    |    *pchar = rxb.data[rxb.head]; // Copy character     |
    |                                   // pointed by head  |
    |    rxb.count--;                  // Decrement count   |
    |    rxb.head = (rxb.head + 1)     // Increment head    |
    |               & (BUF_SIZE-1);     // (mod BUF_SIZE)   |
    |    EnableUartRxInterrupts();     // End of atomic     |
    |                                   // operation        |
    |    return TRUE;                                       |
    |}                                                      |
    +-------------------------------------------------------+

    +-------------------------------------------------------+
    |void _int_(UART_1_VECTOR) isr_rx(void)                 |
    |{                                                      |
    |    if(IFS0bits.U1RXIF == 1) // if U1RXIF is set       |
    |    {                                                  |
    |        rxb.data[rxb.tail] = U1RXREG; // Read character|
    |        rxb.tail = (rxb.tail + 1)   // Increment tail  |
    |                   & (BUF_SIZE-1);   // (mod BUF_SIZE) |
    |        if(rxb.count < BUF_SIZE) // If buffer is not   |
    |                                  // full              |
    |            rxb.count++;        // Increment count     |
    |    }                                                  |
    |    IFS0bits.U1RXIF = 0; // Reset UART1 RX interrupt   |
    |}                                                      |
    +-------------------------------------------------------+

--------------------------------------------------------------------------------------------
!!! Pergunta !!!
111. Se tivesse que identificar as principais características de um device driver,
    como descreveria na perspetiva:
    a. do Sistema Operativo ou das aplicações
    b. do lado da interface com o dispositivo periférico

< Resposta >
    a. do Sistema Operativo ou das aplicações
        - Um programa que fornece uma camada de abstração para o acesso a um
            dispositivo de hardware
        - Uniformiza o acesso a diferentes dispositivos de uma mesma classe
        - Permite a independência entre aplicações/SO e o hardware

    b. do lado da interface com o dispositivo periférico
        - Fornece uma interface de acesso ao dispositivo de hardware
        - Implementa a camada de abstração e lida com as particularidades do
            dispositivo controlado
        - Como o Device Driver tem de lidar com os aspetos específicos da
            implementação física, o seu fornecimento é sempre assegurado pelo
            fabricante

    Ou seja, atua como um tradutor entre as aplicações/SO e o hardware,
        permitindo que ambos possam comunicar entre si sem terem de saber
        como é que o outro funciona.
        
--------------------------------------------------------------------------------------------
!!! Pergunta !!!
112. Quando se interliga um periférico com um sistema de processamento,
quem é responsável por fornecer o software do device driver? Porquê?

< Resposta >
    O fabricante do periférico é normalmente responsável por fornecer o software do device
        porque conhece a implementação do periférico e, por isso, é do seu interesse
        fornecer um software que permita o acesso ao periférico de forma eficiente.

--------------------------------------------------------------------------------------------
!!! Pergunta !!!
113. Um dispositibo UART (RS-232C), usa para a transmissão e receção de dados,
    dois buffers circulares.
    a. Descreva o princípio de funcionamento de um buffer circular.
    b. Quais são as principais variáveis necessárias para gerir um buffer circular?
    c. Destas variáveis há uma cuja gestão é gerida pela aplicação e pelo device driver.
        Qual é essa variável e que cuidados há a ter com ela quando é acedida pela
        aplicação?

< Resposta >
    a. Um buffer circular é um buffer que é implementado através de um array linear,
        no qual os índices de escrita e leitura indicam a posição onde se vai escrever
        o próximo elemento (tail) e a posição onde se vai ler o próximo elemento (head).
    b. As principais variáveis necessárias para gerir um buffer circular são:
        data[] -> array linear que contém os elementos do buffer
        head -> índice de leitura do próximo elemento
        tail -> índice de escrita do próximo elemento
        count -> número de elementos que estão no buffer
    c. A variável é count.
        Quando é acedida pela aplicação, deve ser protegida por um
        mecanismo de exclusão mútua, para que não haja problemas de concorrência.
        Este mecanismo de exclusão mútua pode ser implementado através da
        desativação das interrupções durante a atualização do contador.

!!! Pergunta !!!
114. Descreva por palavras suas o que se entende por secção crítica num trecho de código?

< Resposta >
    Uma secção crítica é um trecho de código que acede a um recurso partilhado
        e que deve ser protegido por um mecanismo de exclusão mútua, para que
        não haja problemas de concorrência.